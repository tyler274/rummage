<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Replicon RNG Tests - Rummage Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for the Rummage MTG Commander game engine built with Bevy 0.15.x">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/css/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rummage Documentation</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/your-org/rummage" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/your-org/rummage/edit/main/docs/./networking/testing/replicon_rng_tests.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="testing-replicon-integration-with-rng-state-management"><a class="header" href="#testing-replicon-integration-with-rng-state-management">Testing Replicon Integration with RNG State Management</a></h1>
<p>This document outlines specific test cases and methodologies for verifying the correct integration of bevy_replicon with our RNG state management system.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#test-environment-setup">Test Environment Setup</a></li>
<li><a href="#unit-tests">Unit Tests</a></li>
<li><a href="#integration-tests">Integration Tests</a></li>
<li><a href="#end-to-end-tests">End-to-End Tests</a></li>
<li><a href="#performance-tests">Performance Tests</a></li>
<li><a href="#debugging-failures">Debugging Failures</a></li>
</ol>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Testing the integration of bevy_replicon with RNG state management presents unique challenges:</p>
<ol>
<li>Network conditions are variable and unpredictable</li>
<li>Randomized operations must be deterministic across network boundaries</li>
<li>Rollbacks must preserve the exact RNG state</li>
<li>Any deviations in RNG state can lead to unpredictable game outcomes</li>
</ol>
<p>Our testing approach focuses on verifying determinism under various network conditions and ensuring proper recovery after disruptions.</p>
<h2 id="test-environment-setup"><a class="header" href="#test-environment-setup">Test Environment Setup</a></h2>
<h3 id="local-network-testing-harness"><a class="header" href="#local-network-testing-harness">Local Network Testing Harness</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Struct for testing replicon and RNG integration 
pub struct RepliconRngTestHarness {
    /// Server application
    pub server_app: App,
    /// Client applications (can have multiple)
    pub client_apps: Vec&lt;App&gt;,
    /// Network conditions simulator
    pub network_conditions: NetworkConditionSimulator,
    /// Test seed for deterministic behavior
    pub test_seed: u64,
}

impl RepliconRngTestHarness {
    /// Create a new test harness with the specified number of clients
    pub fn new(num_clients: usize) -&gt; Self {
        let mut server_app = App::new();
        let mut client_apps = Vec::with_capacity(num_clients);
        
        // Setup server
        server_app.add_plugins(MinimalPlugins)
                  .add_plugins(DefaultRngPlugin)
                  .add_plugins(RepliconServerPlugin::default())
                  .add_plugin(RepliconRngRollbackPlugin);
        
        // Setup RNG with specific seed for repeatability
        let test_seed = 12345u64;
        server_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;().seed_from_u64(test_seed);
        
        // Setup clients
        for _ in 0..num_clients {
            let mut client_app = App::new();
            client_app.add_plugins(MinimalPlugins)
                     .add_plugins(DefaultRngPlugin)
                     .add_plugins(RepliconClientPlugin::default())
                     .add_plugin(RepliconRngRollbackPlugin);
                     
            // Each client gets the same seed
            client_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;().seed_from_u64(test_seed);
            
            client_apps.push(client_app);
        }
        
        Self {
            server_app,
            client_apps,
            network_conditions: NetworkConditionSimulator::default(),
            test_seed,
        }
    }
    
    /// Connect all clients to the server
    pub fn connect_all_clients(&amp;mut self) {
        // Setup server to listen
        let server_port = 8080;
        self.server_app.world.resource_mut::&lt;RepliconServer&gt;()
            .start_endpoint(ServerEndpoint::new(server_port));
        
        // Connect clients
        for (i, client_app) in self.client_apps.iter_mut().enumerate() {
            client_app.world.resource_mut::&lt;RepliconClient&gt;()
                .connect_endpoint(ClientEndpoint::new("127.0.0.1", server_port));
        }
        
        // Update a few times to establish connections
        for _ in 0..10 {
            self.server_app.update();
            for client_app in &amp;mut self.client_apps {
                client_app.update();
            }
        }
    }
    
    /// Simulate network disruption for a specific client
    pub fn simulate_disruption(&amp;mut self, client_idx: usize, duration_ms: u64) {
        self.network_conditions.disconnect_client(client_idx, duration_ms);
    }
    
    /// Run a test with network conditions
    pub fn run_with_conditions&lt;F&gt;(&amp;mut self, update_count: usize, test_fn: F) 
    where F: Fn(&amp;mut Self, usize) {
        for i in 0..update_count {
            // Apply network conditions
            self.network_conditions.update(&amp;mut self.client_apps);
            
            // Run server update
            self.server_app.update();
            
            // Run client updates
            for client_app in &amp;mut self.client_apps {
                client_app.update();
            }
            
            // Call test function
            test_fn(self, i);
        }
    }
}

/// Simulates different network conditions
pub struct NetworkConditionSimulator {
    /// Client disconnection timers
    pub disconnection_timers: HashMap&lt;usize, u64&gt;,
    /// Packet loss percentages
    pub packet_loss_rates: HashMap&lt;usize, f32&gt;,
    /// Latency values
    pub latencies: HashMap&lt;usize, u64&gt;,
}

impl NetworkConditionSimulator {
    /// Disconnect a client for a duration
    pub fn disconnect_client(&amp;mut self, client_idx: usize, duration_ms: u64) {
        self.disconnection_timers.insert(client_idx, duration_ms);
    }
    
    /// Apply network conditions to clients
    pub fn update(&amp;mut self, client_apps: &amp;mut [App]) {
        // Update disconnection timers and reconnect if needed
        let mut reconnect = Vec::new();
        for (client_idx, timer) in &amp;mut self.disconnection_timers {
            if *timer &lt;= 16 {
                reconnect.push(*client_idx);
            } else {
                *timer -= 16; // Assuming 60 FPS
            }
        }
        
        for client_idx in reconnect {
            self.disconnection_timers.remove(&amp;client_idx);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<h3 id="testing-rng-state-serialization-and-deserialization"><a class="header" href="#testing-rng-state-serialization-and-deserialization">Testing RNG State Serialization and Deserialization</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_rng_state_serialization() {
    // Create a test app
    let mut app = App::new();
    app.add_plugins(MinimalPlugins)
       .add_plugins(DefaultRngPlugin)
       .init_resource::&lt;RngReplicationState&gt;();
    
    // Setup global RNG with specific seed
    let test_seed = 12345u64;
    app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;().seed_from_u64(test_seed);
    
    // Generate some random values and store them
    let original_values: Vec&lt;u32&gt; = {
        let mut rng = app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..10).map(|_| rng.gen::&lt;u32&gt;()).collect()
    };
    
    // Capture the RNG state
    let mut rng_state = app.world.resource_mut::&lt;RngReplicationState&gt;();
    let global_rng = app.world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
    rng_state.global_state = global_rng.try_serialize_state().unwrap();
    
    // Create a new app with fresh RNG
    let mut new_app = App::new();
    new_app.add_plugins(MinimalPlugins)
           .add_plugins(DefaultRngPlugin);
    
    // Apply the saved state
    let mut new_global_rng = new_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
    new_global_rng.deserialize_state(&amp;rng_state.global_state).unwrap();
    
    // Generate values from the new RNG
    let new_values: Vec&lt;u32&gt; = {
        let mut rng = new_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..10).map(|_| rng.gen::&lt;u32&gt;()).collect()
    };
    
    // Values should be different from the original sequence
    // because we captured the state after generating the original values
    assert_ne!(original_values, new_values);
    
    // Reset both RNGs to the same seed and generate sequences
    app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;().seed_from_u64(test_seed);
    new_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;().seed_from_u64(test_seed);
    
    let reset_values1: Vec&lt;u32&gt; = {
        let mut rng = app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..10).map(|_| rng.gen::&lt;u32&gt;()).collect()
    };
    
    let reset_values2: Vec&lt;u32&gt; = {
        let mut rng = new_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..10).map(|_| rng.gen::&lt;u32&gt;()).collect()
    };
    
    // Values should now be identical
    assert_eq!(reset_values1, reset_values2);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-checkpoint-creation-and-restoration"><a class="header" href="#testing-checkpoint-creation-and-restoration">Testing Checkpoint Creation and Restoration</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_checkpoint_creation_and_restoration() {
    // Create a test app with the plugin
    let mut app = App::new();
    app.add_plugins(MinimalPlugins)
       .add_plugins(DefaultRngPlugin)
       .add_plugin(RepliconRngRollbackPlugin)
       .init_resource::&lt;SequenceTracker&gt;();
    
    // Seed RNG
    let test_seed = 12345u64;
    app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;().seed_from_u64(test_seed);
    
    // Generate some initial values
    let initial_values: Vec&lt;u32&gt; = {
        let mut rng = app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..5).map(|_| rng.gen::&lt;u32&gt;()).collect()
    };
    
    // Create a checkpoint
    let checkpoint_sequence = 1;
    let mut checkpoints = app.world.resource_mut::&lt;RollbackCheckpoints&gt;();
    let rng_state = app.world.resource::&lt;RngReplicationState&gt;();
    let global_rng = app.world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
    
    let checkpoint = RollbackCheckpoint {
        sequence_id: checkpoint_sequence,
        timestamp: 0.0,
        global_rng_state: global_rng.try_serialize_state().unwrap(),
        player_rng_states: HashMap::new(),
        replicated_entities: Vec::new(),
    };
    
    checkpoints.checkpoints.insert(checkpoint_sequence, checkpoint);
    
    // Generate more values after checkpoint
    let post_checkpoint_values: Vec&lt;u32&gt; = {
        let mut rng = app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..5).map(|_| rng.gen::&lt;u32&gt;()).collect()
    };
    
    // Restore from checkpoint
    let checkpoint = checkpoints.checkpoints.get(&amp;checkpoint_sequence).unwrap();
    app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;()
        .deserialize_state(&amp;checkpoint.global_rng_state).unwrap();
    
    // Generate values after restoration
    let restored_values: Vec&lt;u32&gt; = {
        let mut rng = app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..5).map(|_| rng.gen::&lt;u32&gt;()).collect()
    };
    
    // The restored values should match the post-checkpoint values
    assert_eq!(post_checkpoint_values, restored_values);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h2>
<h3 id="testing-rng-synchronization-between-server-and-client"><a class="header" href="#testing-rng-synchronization-between-server-and-client">Testing RNG Synchronization Between Server and Client</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_server_client_rng_sync() {
    // Create test harness with 1 client
    let mut harness = RepliconRngTestHarness::new(1);
    harness.connect_all_clients();
    
    // Test variables
    let mut server_values = Vec::new();
    let mut client_values = Vec::new();
    
    // Run with updates
    harness.run_with_conditions(50, |harness, i| {
        if i == 10 {
            // Record server RNG values at update 10
            let mut rng = harness.server_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            server_values = (0..5).map(|_| rng.gen::&lt;u32&gt;()).collect();
        }
        
        if i == 20 {
            // Record client RNG values at update 20
            // By now, RNG state should have been synced
            let mut rng = harness.client_apps[0].world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            client_values = (0..5).map(|_| rng.gen::&lt;u32&gt;()).collect();
            
            // Server will have advanced, get fresh set of values
            let mut rng = harness.server_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            server_values = (0..5).map(|_| rng.gen::&lt;u32&gt;()).collect();
        }
    });
    
    // Client values should match server values from update 20
    assert_eq!(client_values, server_values);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-rollback-due-to-network-disruption"><a class="header" href="#testing-rollback-due-to-network-disruption">Testing Rollback Due to Network Disruption</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_rollback_after_disruption() {
    // Create test harness with 2 clients
    let mut harness = RepliconRngTestHarness::new(2);
    harness.connect_all_clients();
    
    // Setup game entities
    // ...
    
    // Run test with network disruption
    let mut pre_disruption_rng_values = Vec::new();
    let mut post_disruption_rng_values = Vec::new();
    let mut post_rollback_rng_values = Vec::new();
    
    harness.run_with_conditions(100, |harness, i| {
        if i == 20 {
            // Record RNG values before disruption
            let rng = harness.server_app.world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            pre_disruption_rng_values = generate_test_random_values(rng, 10);
            
            // Simulate network disruption for client 0
            harness.simulate_disruption(0, 500); // 500ms disruption
        }
        
        if i == 40 {
            // Record RNG values after disruption
            let rng = harness.server_app.world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            post_disruption_rng_values = generate_test_random_values(rng, 10);
        }
        
        if i == 60 {
            // By now rollback should have happened
            // Record RNG values after rollback
            let rng = harness.server_app.world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            post_rollback_rng_values = generate_test_random_values(rng, 10);
            
            // Check that client 0 and client 1 have the same RNG state
            let rng0 = harness.client_apps[0].world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            let rng1 = harness.client_apps[1].world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            
            let client0_values = generate_test_random_values(rng0, 10);
            let client1_values = generate_test_random_values(rng1, 10);
            
            assert_eq!(client0_values, client1_values, "Clients should have same RNG state after rollback");
        }
    });
    
    // Verify behavior
    assert_ne!(pre_disruption_rng_values, post_disruption_rng_values, 
               "RNG values should change during normal operation");
    assert_eq!(post_rollback_rng_values, post_disruption_rng_values, 
               "After rollback, RNG sequences should match the checkpoint state");
}

/// Helper function to generate random values for testing
fn generate_test_random_values(rng: &amp;GlobalEntropy&lt;WyRand&gt;, count: usize) -&gt; Vec&lt;u32&gt; {
    let mut rng_clone = rng.clone();
    (0..count).map(|_| rng_clone.gen::&lt;u32&gt;()).collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="end-to-end-tests"><a class="header" href="#end-to-end-tests">End-to-End Tests</a></h2>
<h3 id="testing-card-shuffling-during-network-disruption"><a class="header" href="#testing-card-shuffling-during-network-disruption">Testing Card Shuffling During Network Disruption</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_card_shuffle_during_disruption() {
    // Setup test environment with card library
    let mut harness = RepliconRngTestHarness::new(2);
    harness.connect_all_clients();
    
    // Create players and libraries
    let server_player1 = setup_test_player(&amp;mut harness.server_app.world, 1);
    let server_player2 = setup_test_player(&amp;mut harness.server_app.world, 2);
    
    // Create identical card libraries
    let cards = (1..53).collect::&lt;Vec&lt;i32&gt;&gt;();
    let server_library1 = create_test_library(&amp;mut harness.server_app.world, server_player1, cards.clone());
    let server_library2 = create_test_library(&amp;mut harness.server_app.world, server_player2, cards.clone());
    
    // Initialize client players and libraries
    // ...
    
    // Shuffle results
    let mut server_shuffle_result1 = Vec::new();
    let mut server_shuffle_result2 = Vec::new();
    let mut client1_shuffle_result = Vec::new();
    let mut client2_shuffle_result = Vec::new();
    
    // Run test with network disruption during card shuffle
    harness.run_with_conditions(200, |harness, i| {
        if i == 50 {
            // Player 1 shuffles their library
            harness.server_app.world.send_event(ShuffleLibraryEvent { 
                library_entity: server_library1 
            });
        }
        
        if i == 60 {
            // Capture shuffle result
            server_shuffle_result1 = get_library_order(&amp;harness.server_app.world, server_library1);
            
            // Cause network disruption
            harness.simulate_disruption(0, 1000);
        }
        
        if i == 80 {
            // Player 2 shuffles during disruption
            harness.server_app.world.send_event(ShuffleLibraryEvent { 
                library_entity: server_library2 
            });
        }
        
        if i == 100 {
            // Capture server-side shuffle results
            server_shuffle_result2 = get_library_order(&amp;harness.server_app.world, server_library2);
        }
        
        if i == 150 {
            // By now, rollback and resynchronization should have occurred
            // Capture client-side shuffle results
            client1_shuffle_result = get_client_library_order(&amp;harness.client_apps[0].world, 1);
            client2_shuffle_result = get_client_library_order(&amp;harness.client_apps[1].world, 2);
        }
    });
    
    // Verify all libraries have the same shuffle result
    assert_eq!(server_shuffle_result1, client1_shuffle_result, 
               "Client 1 should have same shuffle result as server");
    assert_eq!(server_shuffle_result2, client2_shuffle_result, 
               "Client 2 should have same shuffle result as server");
}

/// Helper function to get library card order
fn get_library_order(world: &amp;World, library_entity: Entity) -&gt; Vec&lt;i32&gt; {
    if let Some(library) = world.get::&lt;Library&gt;(library_entity) {
        library.cards.clone()
    } else {
        Vec::new()
    }
}

/// Helper function to get client-side library order
fn get_client_library_order(client_world: &amp;World, player_id: i32) -&gt; Vec&lt;i32&gt; {
    // Find player by ID
    let player_entity = find_player_by_id(client_world, player_id);
    if player_entity.is_none() { return Vec::new(); }
    
    // Find library entity
    let library_entity = find_library_for_player(client_world, player_entity.unwrap());
    if library_entity.is_none() { return Vec::new(); }
    
    // Get library cards
    get_library_order(client_world, library_entity.unwrap())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-tests"><a class="header" href="#performance-tests">Performance Tests</a></h2>
<h3 id="testing-rng-state-replication-bandwidth"><a class="header" href="#testing-rng-state-replication-bandwidth">Testing RNG State Replication Bandwidth</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_rng_replication_bandwidth() {
    // Create a test harness with multiple clients
    let mut harness = RepliconRngTestHarness::new(4);
    harness.connect_all_clients();
    
    // Setup bandwidth tracking
    let mut bandwidth_tracker = BandwidthTracker::new();
    
    // Run test with bandwidth monitoring
    harness.run_with_conditions(100, |harness, i| {
        if i % 10 == 0 {
            // Record bandwidth usage every 10 updates
            let server = harness.server_app.world.resource::&lt;RepliconServer&gt;();
            bandwidth_tracker.record_bandwidth(server.get_bandwidth_stats());
        }
    });
    
    // Analyze bandwidth results
    let results = bandwidth_tracker.analyze();
    
    // Ensure RNG state replication is within reasonable bounds
    assert!(results.avg_bandwidth_per_client &lt; 1024, 
            "Average bandwidth should be less than 1KB per client");
    
    // Print results
    println!("Bandwidth results:");
    println!("  Average per client: {} bytes", results.avg_bandwidth_per_client);
    println!("  Peak: {} bytes", results.peak_bandwidth);
    println!("  Total: {} bytes", results.total_bandwidth);
}

/// Helper struct for tracking bandwidth usage
struct BandwidthTracker {
    samples: Vec&lt;BandwidthSample&gt;,
}

struct BandwidthSample {
    timestamp: f32,
    bytes_sent: usize,
    client_count: usize,
}

struct BandwidthResults {
    avg_bandwidth_per_client: f32,
    peak_bandwidth: usize,
    total_bandwidth: usize,
}

impl BandwidthTracker {
    fn new() -&gt; Self {
        Self { samples: Vec::new() }
    }
    
    fn record_bandwidth(&amp;mut self, stats: BandwidthStats) {
        self.samples.push(BandwidthSample {
            timestamp: stats.timestamp,
            bytes_sent: stats.bytes_sent,
            client_count: stats.client_count,
        });
    }
    
    fn analyze(&amp;self) -&gt; BandwidthResults {
        if self.samples.is_empty() {
            return BandwidthResults {
                avg_bandwidth_per_client: 0.0,
                peak_bandwidth: 0,
                total_bandwidth: 0,
            };
        }
        
        let total_bytes: usize = self.samples.iter().map(|s| s.bytes_sent).sum();
        let peak_bytes = self.samples.iter().map(|s| s.bytes_sent).max().unwrap_or(0);
        
        let client_samples: usize = self.samples.iter().map(|s| s.client_count).sum();
        let avg_per_client = if client_samples &gt; 0 {
            total_bytes as f32 / client_samples as f32
        } else {
            0.0
        };
        
        BandwidthResults {
            avg_bandwidth_per_client: avg_per_client,
            peak_bandwidth: peak_bytes,
            total_bandwidth: total_bytes,
        }
    }
}

/// Mock struct to represent network bandwidth statistics
struct BandwidthStats {
    timestamp: f32,
    bytes_sent: usize,
    client_count: usize,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="debugging-failures"><a class="header" href="#debugging-failures">Debugging Failures</a></h2>
<p>When tests fail, collect diagnostic information to aid debugging:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn diagnose_rng_state_mismatch(
    server_rng: &amp;GlobalEntropy&lt;WyRand&gt;,
    client_rng: &amp;GlobalEntropy&lt;WyRand&gt;,
) -&gt; String {
    // Serialize both RNG states
    let server_state = server_rng.try_serialize_state().unwrap_or_default();
    let client_state = client_rng.try_serialize_state().unwrap_or_default();
    
    // Generate test values from both
    let mut server_rng_clone = server_rng.clone();
    let mut client_rng_clone = client_rng.clone();
    
    let server_values: Vec&lt;u32&gt; = (0..5).map(|_| server_rng_clone.gen::&lt;u32&gt;()).collect();
    let client_values: Vec&lt;u32&gt; = (0..5).map(|_| client_rng_clone.gen::&lt;u32&gt;()).collect();
    
    let mut report = String::new();
    report.push_str("RNG State Mismatch Diagnostic:\n");
    report.push_str(&amp;format!("Server state: {:?}\n", server_state));
    report.push_str(&amp;format!("Client state: {:?}\n", client_state));
    report.push_str(&amp;format!("Server values: {:?}\n", server_values));
    report.push_str(&amp;format!("Client values: {:?}\n", client_values));
    
    report
}
<span class="boring">}</span></code></pre></pre>
<hr />
<p>These tests validate that our bevy_replicon integration with RNG state management works correctly under various conditions, ensuring deterministic behavior in our networked MTG Commander game.</p>
<p>Remember to run these tests:</p>
<ol>
<li>Regularly during development</li>
<li>After any changes to networking code</li>
<li>After any changes to RNG-dependent game logic</li>
<li>As part of the CI/CD pipeline</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../networking/testing/rng_synchronization_tests.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../networking/security/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../networking/testing/rng_synchronization_tests.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../networking/security/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/js/custom.js"></script>


    </div>
    </body>
</html>
