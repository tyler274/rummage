<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rummage Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Documentation for the Rummage MTG Commander game engine built with Bevy 0.15.x">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rummage Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/your-org/rummage" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rummage---mtg-commander-game-engine-documentation"><a class="header" href="#rummage---mtg-commander-game-engine-documentation">Rummage - MTG Commander Game Engine Documentation</a></h1>
<p>Welcome to the official documentation for Rummage, a robust end-to-end tested Magic: The Gathering Commander format game engine built with Bevy 0.15.x.</p>
<h2 id="documentation-structure"><a class="header" href="#documentation-structure">Documentation Structure</a></h2>
<p>The documentation is organized into the following major sections:</p>
<ol>
<li><strong><a href="commander/index.html">Commander Rules</a></strong> - Implementation of MTG Commander format rules and mechanics</li>
<li><strong><a href="game_gui/index.html">Game UI</a></strong> - User interface systems and components</li>
<li><strong><a href="networking/index.html">Networking</a></strong> - Multiplayer functionality using bevy_replicon</li>
</ol>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>If you're new to the project, we recommend starting with the following documents:</p>
<ul>
<li><a href="commander/overview/index.html">Commander Format Overview</a> - Introduction to the Commander format</li>
<li><a href="game_gui/overview.html">Game UI Overview</a> - Introduction to the game's user interface</li>
<li><a href="networking/core/architecture_overview.html">Networking Overview</a> - Introduction to the networking architecture</li>
</ul>
<h2 id="implementation-status"><a class="header" href="#implementation-status">Implementation Status</a></h2>
<p>This documentation represents both implemented features and design specifications for planned features. Components are marked as follows:</p>
<ul>
<li>‚úÖ Implemented and tested</li>
<li>üîÑ In progress</li>
<li>‚ö†Ô∏è Planned but not yet implemented</li>
</ul>
<h2 id="development-standards"><a class="header" href="#development-standards">Development Standards</a></h2>
<p>The Rummage codebase adheres to the following standards:</p>
<ol>
<li><strong>Bevy 0.15.x Compatibility</strong>: Using non-deprecated Bevy APIs</li>
<li><strong>End-to-End Testing</strong>: Comprehensive test coverage for all features</li>
<li><strong>Documentation-First Development</strong>: New features are documented before implementation</li>
<li><strong>Performance Focus</strong>: Optimization for smooth gameplay</li>
</ol>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>If you're interested in contributing to the Rummage project, please review:</p>
<ol>
<li>The <a href="https://github.com/your-org/rummage">GitHub repository</a></li>
<li>Our <a href="CONTRIBUTING.html">contribution guidelines</a></li>
<li>The <a href="CODE_OF_CONDUCT.html">code of conduct</a></li>
</ol>
<h2 id="reference-materials"><a class="header" href="#reference-materials">Reference Materials</a></h2>
<p>The implementation is based on official MTG rules:</p>
<ul>
<li><a href="https://magic.wizards.com/en/rules">Magic: The Gathering Comprehensive Rules</a></li>
<li><a href="https://mtgcommander.net/index.php/rules/">Commander Format Rules</a></li>
</ul>
<p>A local copy of the comprehensive rules is available in this repository: <a href="MagicCompRules%2020250207.txt">MagicCompRules 20250207.txt</a>.</p>
<hr />
<p>This documentation will evolve as the project progresses. Last updated: March 2025.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commander-format-documentation"><a class="header" href="#commander-format-documentation">Commander Format Documentation</a></h1>
<p>This section covers the implementation of the Magic: The Gathering Commander format in the Rummage game engine.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="commander/index.html#overview">Overview</a></li>
<li><a href="commander/index.html#structure">Structure</a></li>
<li><a href="commander/index.html#key-commander-rules">Key Commander Rules</a></li>
<li><a href="commander/index.html#testing-approach">Testing Approach</a></li>
</ol>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Commander (formerly known as Elder Dragon Highlander or EDH) is a multiplayer format for Magic: The Gathering with the following key characteristics:</p>
<ul>
<li>100-card singleton format (only one copy of each card except for basic lands)</li>
<li>Each player has a legendary creature designated as their "commander"</li>
<li>Deck can only include cards that match the color identity of the commander</li>
<li>Players start with 40 life</li>
<li>Commanders begin in the Command Zone and can be cast for an increasing cost</li>
<li>21 combat damage from a single commander causes a player to lose</li>
</ul>
<p>This documentation outlines our implementation of these rules and mechanics in the Rummage game engine.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>The documentation is organized into the following sections:</p>
<ul>
<li><a href="commander/overview/index.html">Overview</a> - High-level overview of the Commander format and implementation approach</li>
<li><a href="commander/game_mechanics/index.html">Game Mechanics</a> - Core game state and mechanics implementation
<ul>
<li>Game State Management</li>
<li>State-Based Actions</li>
<li>Random Mechanics (coin flips, dice rolls)</li>
</ul>
</li>
<li><a href="commander/player_mechanics/index.html">Player Mechanics</a> - Player-specific rules and interactions
<ul>
<li>Life Total Management</li>
<li>Commander Tax</li>
<li>Color Identity</li>
</ul>
</li>
<li><a href="commander/zones/index.html">Game Zones</a> - Implementation of game zones, especially the Command Zone
<ul>
<li>Command Zone</li>
<li>Zone Transfers</li>
<li>Zone-specific Rules</li>
</ul>
</li>
<li><a href="commander/turns_and_phases/index.html">Turns and Phases</a> - Turn structure and phase management
<ul>
<li>Turn Order</li>
<li>Phase Management</li>
<li>Multiplayer Considerations</li>
</ul>
</li>
<li><a href="commander/stack_and_priority/index.html">Stack and Priority</a> - Stack implementation and priority system
<ul>
<li>Priority Passing</li>
<li>Stack Resolution</li>
<li>Special Timing Rules</li>
</ul>
</li>
<li><a href="commander/combat/index.html">Combat</a> - Combat mechanics including commander damage
<ul>
<li>Combat Phases</li>
<li>Commander Damage Tracking</li>
<li>Multiplayer Combat</li>
</ul>
</li>
<li><a href="commander/special_rules/index.html">Special Rules</a> - Format-specific rules and unique mechanics
<ul>
<li>Partner Commanders</li>
<li>Commander Death Triggers</li>
<li>Commander-specific Abilities</li>
</ul>
</li>
</ul>
<h2 id="key-commander-rules"><a class="header" href="#key-commander-rules">Key Commander Rules</a></h2>
<p>The following key Commander rules are implemented in our engine:</p>
<div class="table-wrapper"><table><thead><tr><th>Rule</th><th>Description</th><th>Implementation Status</th></tr></thead><tbody>
<tr><td>Singleton</td><td>Only one copy of each card allowed (except basic lands)</td><td>‚úÖ</td></tr>
<tr><td>Commander</td><td>Legendary creature in command zone</td><td>‚úÖ</td></tr>
<tr><td>Color Identity</td><td>Cards must match commander's color identity</td><td>‚úÖ</td></tr>
<tr><td>Command Zone</td><td>Special zone for commanders</td><td>‚úÖ</td></tr>
<tr><td>Commander Tax</td><td>Additional {2} cost each time cast from command zone</td><td>‚úÖ</td></tr>
<tr><td>Commander Damage</td><td>21 combat damage from a single commander</td><td>‚úÖ</td></tr>
<tr><td>Starting Life</td><td>40 life points</td><td>‚úÖ</td></tr>
<tr><td>Commander Replacement</td><td>Optional replacement to command zone</td><td>‚úÖ</td></tr>
<tr><td>Partner Commanders</td><td>Special commanders that can be paired</td><td>üîÑ</td></tr>
<tr><td>Commander Ninjutsu</td><td>Special ability for certain commanders</td><td>‚ö†Ô∏è</td></tr>
<tr><td>Commander-specific Cards</td><td>Cards that reference the command zone or commanders</td><td>üîÑ</td></tr>
</tbody></table>
</div>
<h2 id="testing-approach"><a class="header" href="#testing-approach">Testing Approach</a></h2>
<p>Each section includes detailed test cases to validate the correct implementation of Commander rules. Our testing approach ensures:</p>
<ol>
<li>Full coverage of Commander-specific rules</li>
<li>Edge case handling for unique interactions</li>
<li>Performance validation for multiplayer scenarios</li>
<li>Verification of correct rule application in complex board states</li>
</ol>
<p>For implementation details, see the respective sections.</p>
<hr />
<p>For more information on the official Commander rules, refer to the <a href="https://mtgcommander.net/index.php/rules/">Commander Format Rules</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commander-overview"><a class="header" href="#commander-overview">Commander Overview</a></h1>
<p>This section provides a high-level overview of the Commander format implementation in our game engine.</p>
<h2 id="contents"><a class="header" href="#contents">Contents</a></h2>
<ul>
<li><a href="commander/overview/format_rules.html">Format Rules</a> - Core rules specific to the Commander format</li>
<li><a href="commander/overview/architecture.html">Architecture</a> - Overview of the implementation architecture</li>
<li><a href="commander/overview/implementation.html">Implementation Approach</a> - General approach to implementing the Commander format</li>
</ul>
<h2 id="format-summary"><a class="header" href="#format-summary">Format Summary</a></h2>
<p>The Commander format is a multiplayer variant of Magic: The Gathering with special rules including:</p>
<ul>
<li>Each player begins the game with a designated legendary creature as their "commander"</li>
<li>Players start with 40 life</li>
<li>A player can cast their commander from the command zone for its mana cost, plus an additional 2 mana for each previous time it's been cast</li>
<li>If a commander would be put into a library, hand, graveyard or exile, its owner may choose to move it to the command zone</li>
<li>A player who has been dealt 21 or more combat damage by the same commander loses the game</li>
</ul>
<h2 id="implementation-principles"><a class="header" href="#implementation-principles">Implementation Principles</a></h2>
<p>Our implementation of the Commander format follows these key principles:</p>
<ol>
<li><strong>Rule Accuracy</strong> - Faithful implementation of the official Commander rules</li>
<li><strong>Performance</strong> - Optimized for multiplayer games with complex board states</li>
<li><strong>Extensibility</strong> - Designed to easily incorporate new Commander-specific cards and mechanics</li>
<li><strong>Testability</strong> - Comprehensive test suite for validating format-specific rules</li>
</ol>
<p>See the <a href="commander/overview/implementation.html">Implementation Approach</a> document for more detailed information on how these principles are applied in our codebase.</p>
<h2 id="related-sections"><a class="header" href="#related-sections">Related Sections</a></h2>
<ul>
<li><a href="commander/overview/../game_mechanics/index.html">Game Mechanics</a> - For detailed mechanics implementation</li>
<li><a href="commander/overview/../combat/index.html">Combat</a> - For Commander damage tracking and combat interactions</li>
<li><a href="commander/overview/../zones/index.html">Game Zones</a> - For Command Zone implementation details</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-mechanics"><a class="header" href="#game-mechanics">Game Mechanics</a></h1>
<p>This section covers the core game mechanics specific to the Commander format implementation.</p>
<h2 id="contents-1"><a class="header" href="#contents-1">Contents</a></h2>
<ul>
<li><a href="commander/game_mechanics/game_state.html">Game State</a> - Core state tracking and management</li>
<li><a href="commander/game_mechanics/state_based_actions.html">State-Based Actions</a> - Commander-specific state checks and automatic game actions</li>
<li><a href="commander/game_mechanics/random_mechanics.html">Random Mechanics</a> - Testing random elements like coin flips and dice rolls</li>
<li><a href="commander/game_mechanics/special_rules.html">Special Rules</a> - Unique Commander format rules implementation</li>
</ul>
<p>The game mechanics section defines how the Commander format's unique rules are implemented and enforced within our game engine, including:</p>
<ul>
<li>Commander-specific state tracking</li>
<li>Unique state-based actions like commander damage checks</li>
<li>Special replacement effects for Commander cards</li>
<li>Handling multiple player elimination and game completion</li>
<li>Randomized mechanics like coin flips and dice rolls</li>
</ul>
<p>These mechanics build on the foundational Magic: The Gathering rules while incorporating the unique aspects of the Commander format.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="player-mechanics"><a class="header" href="#player-mechanics">Player Mechanics</a></h1>
<p>This section covers player-specific mechanics in the Commander format implementation.</p>
<h2 id="contents-2"><a class="header" href="#contents-2">Contents</a></h2>
<ul>
<li><a href="commander/player_mechanics/player_management.html">Player Management</a> - Player data structures and basic player operations</li>
<li><a href="commander/player_mechanics/commander_damage.html">Commander Damage</a> - Tracking and implementing the 21-damage rule</li>
<li><a href="commander/player_mechanics/multiplayer_politics.html">Multiplayer Politics</a> - Voting, deals, and other social mechanics</li>
</ul>
<p>The player mechanics section defines how players interact within the Commander format, including:</p>
<ul>
<li>Starting with 40 life (compared to 20 in standard Magic)</li>
<li>Commander damage tracking (21+ combat damage from a single commander causes a loss)</li>
<li>Turn order and priority management in multiplayer</li>
<li>Special multiplayer interactions like voting, monarch status, and political deals</li>
<li>Player elimination and handling of player-owned objects after elimination</li>
</ul>
<p>These mechanics are essential for correctly implementing the multiplayer aspects of Commander, especially with games supporting between 2 and 13 players.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-zones"><a class="header" href="#game-zones">Game Zones</a></h1>
<p>This section covers the implementation of game zones in the Commander format, with special focus on the Command Zone.</p>
<h2 id="contents-3"><a class="header" href="#contents-3">Contents</a></h2>
<ul>
<li><a href="commander/zones/command_zone.html">Command Zone</a> - Management of the Command Zone and commander movement</li>
<li><a href="commander/zones/zone_transitions.html">Zone Transitions</a> - Special rules for commander movement between zones</li>
<li><a href="commander/zones/zone_management.html">Zone Management</a> - General zone implementation for Commander games</li>
</ul>
<p>The zones section defines how the unique zone mechanics of Commander are implemented, including:</p>
<ul>
<li>The Command Zone as a special game zone where commanders start the game</li>
<li>Commander-specific zone transition rules (optional movement to command zone)</li>
<li>Commander tax implementation (additional {2} cost for each previous cast from command zone)</li>
<li>Tracking of commanders across all game zones</li>
<li>Special handling for partner commanders and backgrounds</li>
</ul>
<p>These zone implementations are critical for the proper functioning of the Commander format, as they enable many of the format's unique gameplay mechanics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="turns-and-phases"><a class="header" href="#turns-and-phases">Turns and Phases</a></h1>
<p>This section covers the implementation of turn structure and phases in the Commander format.</p>
<h2 id="contents-4"><a class="header" href="#contents-4">Contents</a></h2>
<ul>
<li><a href="commander/turns_and_phases/turn_structure.html">Turn Structure</a> - Complete turn sequence implementation</li>
<li><a href="commander/turns_and_phases/phase_management.html">Phase Management</a> - Handling of individual phases and steps</li>
<li><a href="commander/turns_and_phases/priority_system.html">Priority System</a> - Priority passing within phases</li>
<li><a href="commander/turns_and_phases/extra_turns.html">Extra Turns &amp; Modifications</a> - Extra turns and turn modification effects</li>
<li><a href="commander/turns_and_phases/multiplayer_turn_handling.html">Multiplayer Turn Handling</a> - Multiplayer-specific turn considerations</li>
</ul>
<p>The turns and phases section defines how the turn structure of Commander games is implemented, with special consideration for multiplayer dynamics:</p>
<ul>
<li>Standard Magic turn structure (untap, upkeep, draw, main phases, combat, etc.)</li>
<li>Multiplayer turn order determination and rotation</li>
<li>Special handling for simultaneous player actions</li>
<li>Turn-based effects in multiplayer contexts</li>
<li>Turn modification effects (extra turns, skipped phases, etc.)</li>
</ul>
<p>While the basic turn structure in Commander follows standard Magic rules, the multiplayer nature of the format introduces complexity in turn management, particularly around priority passing and simultaneous effects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-and-priority"><a class="header" href="#stack-and-priority">Stack and Priority</a></h1>
<p>This section covers the implementation of the stack and priority system in the Commander format.</p>
<h2 id="contents-5"><a class="header" href="#contents-5">Contents</a></h2>
<ul>
<li><a href="commander/stack_and_priority/stack.html">The Stack</a> - Implementation of the stack for spells and abilities</li>
<li><a href="commander/stack_and_priority/priority_passing.html">Priority Passing</a> - Priority system in multiplayer games</li>
<li><a href="commander/stack_and_priority/stack_resolution.html">Stack Resolution</a> - Resolution of objects on the stack</li>
</ul>
<p>The stack and priority section defines how spells and abilities are processed in Commander games:</p>
<ul>
<li>Stack implementation for tracking spells and abilities</li>
<li>Priority passing algorithm for multiplayer Commander games</li>
<li>Special timing rules for Commander-specific abilities</li>
<li>Stack resolution mechanics in complex multiplayer scenarios</li>
<li>Handling triggered abilities from multiple players simultaneously</li>
</ul>
<p>The multiplayer nature of Commander introduces unique challenges in stack and priority management, particularly when multiple players have simultaneous triggers or wish to respond to the same action.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combat"><a class="header" href="#combat">Combat</a></h1>
<p>This section covers the implementation of the combat system in the Commander format.</p>
<h2 id="contents-6"><a class="header" href="#contents-6">Contents</a></h2>
<ul>
<li><a href="commander/combat/combat_system.html">Combat System</a> - Core combat mechanics implementation</li>
<li><a href="commander/combat/combat_phases.html">Combat Phases</a> - Overview of the combat phase structure</li>
</ul>
<h3 id="combat-steps"><a class="header" href="#combat-steps">Combat Steps</a></h3>
<ul>
<li><a href="commander/combat/beginning_of_combat.html">Beginning of Combat</a> - Initialization of combat and "beginning of combat" triggers</li>
<li><a href="commander/combat/declare_attackers.html">Declare Attackers</a> - Attack declaration, restrictions, and requirements</li>
<li><a href="commander/combat/declare_blockers.html">Declare Blockers</a> - Block declaration, restrictions, and requirements</li>
<li><a href="commander/combat/first_strike_damage.html">First Strike Damage</a> - Special damage step for first strike and double strike</li>
<li><a href="commander/combat/combat_damage.html">Combat Damage</a> - Damage assignment, ordering, and resolution</li>
<li><a href="commander/combat/end_of_combat.html">End of Combat</a> - Combat cleanup and "end of combat" triggers</li>
</ul>
<h3 id="combat-mechanics"><a class="header" href="#combat-mechanics">Combat Mechanics</a></h3>
<ul>
<li><a href="commander/combat/commander_damage.html">Commander Damage</a> - Tracking and implementation of commander damage</li>
<li><a href="commander/combat/multiplayer_combat.html">Multiplayer Combat</a> - Special rules for combat with multiple players</li>
<li><a href="commander/combat/combat_verification.html">Combat Verification</a> - Validation of combat decisions and actions</li>
<li><a href="commander/combat/combat_abilities.html">Combat Abilities</a> - Implementation of combat-related abilities</li>
</ul>
<h2 id="combat-in-commander"><a class="header" href="#combat-in-commander">Combat in Commander</a></h2>
<p>The combat section defines how combat works in Commander games:</p>
<ul>
<li>Standard combat phases (beginning of combat, declare attackers, declare blockers, combat damage, end of combat)</li>
<li>Commander damage tracking (21+ combat damage from a single commander causes a loss)</li>
<li>Multiplayer attack declaration (attacking different players in the same combat)</li>
<li>Special handling for commander-specific combat abilities</li>
<li>Handling combat triggers in multiplayer scenarios</li>
</ul>
<p>Combat in Commander is particularly complex due to the multiplayer nature of the format and the special rule regarding commander damage, which adds an additional loss condition to the game. The implementation must be robust, handling all edge cases while maintaining good performance and compatibility with the rest of the game engine.</p>
<h2 id="related-systems"><a class="header" href="#related-systems">Related Systems</a></h2>
<p>Combat interacts with several other systems in the Commander implementation:</p>
<ul>
<li><a href="commander/combat/../game_mechanics/random_mechanics.html">Random Mechanics</a> - For combat-related coin flips and dice rolls</li>
<li><a href="commander/combat/../stack_and_priority/index.html">Stack and Priority</a> - For combat triggers and responses</li>
<li><a href="commander/combat/../game_mechanics/state_based_actions.html">State-Based Actions</a> - For checking commander damage thresholds</li>
</ul>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>The <a href="commander/combat/tests/">tests</a> directory contains comprehensive test cases for validating correct combat implementation, including commander damage tracking, multiplayer combat scenarios, and complex ability interactions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="special-rules"><a class="header" href="#special-rules">Special Rules</a></h1>
<p>This section covers special rules and mechanics unique to the Commander format.</p>
<h2 id="contents-7"><a class="header" href="#contents-7">Contents</a></h2>
<ul>
<li><a href="commander/special_rules/color_identity.html">Color Identity</a> - Implementation of color identity restrictions</li>
<li><a href="commander/special_rules/special_cards.html">Special Cards</a> - Commander-specific card mechanics</li>
<li><a href="commander/special_rules/partner_background.html">Partner and Background</a> - Special commander partner mechanics</li>
<li><a href="commander/special_rules/multiplayer_politics.html">Multiplayer Politics</a> - Voting, deals, and social mechanics</li>
</ul>
<h2 id="commander-specific-rules"><a class="header" href="#commander-specific-rules">Commander-Specific Rules</a></h2>
<p>The special rules section covers Commander-specific rules not covered in other sections:</p>
<ul>
<li>Color identity implementation for deck validation</li>
<li>Partner commander mechanics</li>
<li>Background mechanic from Baldur's Gate</li>
<li>Commander-specific card types and abilities</li>
<li>Handling of banned and restricted cards</li>
<li>Multiplayer political mechanics (voting, deal-making, etc.)</li>
</ul>
<p>These special rules are what make Commander unique among Magic: The Gathering formats and require specific implementation details to capture the essence of the format.</p>
<h2 id="related-mechanics"><a class="header" href="#related-mechanics">Related Mechanics</a></h2>
<p>Some Commander-specific mechanics interact with other systems:</p>
<ul>
<li><a href="commander/special_rules/../game_mechanics/random_mechanics.html">Random Mechanics</a> - For coin flips and dice rolls in Commander cards</li>
<li><a href="commander/special_rules/../combat/commander_damage.html">Commander Damage</a> - For tracking commander combat damage</li>
<li><a href="commander/special_rules/../zones/command_zone.html">Command Zone</a> - For commander zone transitions</li>
</ul>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<p>The <a href="commander/special_rules/tests/">tests</a> directory contains test cases for verifying the correct implementation of special Commander rules and edge case handling.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-ui-system-documentation"><a class="header" href="#game-ui-system-documentation">Game UI System Documentation</a></h1>
<p>This section provides a comprehensive overview of the in-game user interface systems for Rummage's Commander format Magic: The Gathering implementation.</p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of Contents</a></h2>
<ol>
<li><a href="game_gui/index.html#overview">Overview</a></li>
<li><a href="game_gui/index.html#key-components">Key Components</a></li>
<li><a href="game_gui/index.html#implementation-status">Implementation Status</a></li>
</ol>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The Game UI system is responsible for rendering the game state, facilitating player interactions, and providing visual feedback. The UI is built using Bevy's Entity Component System (ECS) architecture and follows modern design principles to ensure both usability and visual appeal.</p>
<p>For a more detailed overview, see the <a href="game_gui/overview.html">overview document</a>.</p>
<h2 id="key-components"><a class="header" href="#key-components">Key Components</a></h2>
<p>The Game UI system consists of the following major components:</p>
<ol>
<li>
<p><a href="game_gui/layout/index.html">Layout Components</a></p>
<ul>
<li>Playmat</li>
<li>Command Zone</li>
<li>Battlefield</li>
<li>Player Zones</li>
<li>Stack Visualization</li>
</ul>
</li>
<li>
<p><a href="game_gui/cards/index.html">Card Visualization</a></p>
<ul>
<li>Card Rendering</li>
<li>Card States (Tapped, Exiled, etc.)</li>
<li>Card Animations</li>
</ul>
</li>
<li>
<p><a href="game_gui/interaction/index.html">Interaction Systems</a></p>
<ul>
<li>Card Selection</li>
<li>Drag and Drop</li>
<li>Action Menus</li>
<li>Targeting System</li>
</ul>
</li>
<li>
<p><a href="game_gui/information/index.html">Information Display</a></p>
<ul>
<li>Game Log</li>
<li>Phase Indicators</li>
<li>Priority Visualization</li>
<li>Tooltips and Helpers</li>
</ul>
</li>
<li>
<p><a href="game_gui/flow/index.html">Game Flow</a></p>
<ul>
<li>Turn Visualization</li>
<li>Phase Transitions</li>
<li>Priority Passing</li>
</ul>
</li>
<li>
<p><a href="game_gui/special/index.html">Special UI Elements</a></p>
<ul>
<li>Modal Dialogs</li>
<li>Choice Interfaces</li>
<li>Decision Points</li>
</ul>
</li>
<li>
<p><a href="game_gui/multiplayer/index.html">Multiplayer Considerations</a></p>
<ul>
<li>Player Positioning</li>
<li>Visibility Controls</li>
<li>Opponent Actions</li>
</ul>
</li>
<li>
<p><a href="game_gui/table/index.html">Table View</a></p>
<ul>
<li>Battlefield Layout</li>
<li>Card Stacking</li>
<li>Zone Visualization</li>
</ul>
</li>
<li>
<p><a href="game_gui/playmat/index.html">Playmat Design</a></p>
<ul>
<li>Background Design</li>
<li>Zone Demarcation</li>
<li>Visual Themes</li>
</ul>
</li>
<li>
<p><a href="game_gui/chat/index.html">Chat System</a></p>
<ul>
<li>Message Display</li>
<li>Input Interface</li>
<li>Emotes</li>
</ul>
</li>
<li>
<p><a href="game_gui/avatar/index.html">Avatar System</a></p>
<ul>
<li>Player Avatars</li>
<li>Avatar Selection</li>
<li>Custom Avatar Support</li>
</ul>
</li>
<li>
<p><a href="game_gui/testing/index.html">Testing</a></p>
<ul>
<li>Unit Testing UI Components</li>
<li>Integration Testing</li>
<li>UI Automation Testing</li>
</ul>
</li>
</ol>
<h2 id="implementation-status-1"><a class="header" href="#implementation-status-1">Implementation Status</a></h2>
<p>This documentation represents the design and implementation of the Game UI system. Components are marked as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Status</th><th>Description</th></tr></thead><tbody>
<tr><td>Core UI Framework</td><td>‚úÖ</td><td>Basic UI rendering and interaction system</td></tr>
<tr><td>Card Visualization</td><td>‚úÖ</td><td>Rendering cards and their states</td></tr>
<tr><td>Battlefield Layout</td><td>‚úÖ</td><td>Arrangement of permanents on the battlefield</td></tr>
<tr><td>Hand Interface</td><td>‚úÖ</td><td>Player's hand visualization and interaction</td></tr>
<tr><td>Stack Visualization</td><td>üîÑ</td><td>Visual representation of the spell stack</td></tr>
<tr><td>Command Zone</td><td>üîÑ</td><td>Interface for commanders and command zone abilities</td></tr>
<tr><td>Phase/Turn Indicators</td><td>üîÑ</td><td>Visual indicators for game phases and turns</td></tr>
<tr><td>Player Information</td><td>‚úÖ</td><td>Display of player life, mana, and other stats</td></tr>
<tr><td>Targeting System</td><td>üîÑ</td><td>System for selecting targets for spells and abilities</td></tr>
<tr><td>Decision Interfaces</td><td>‚ö†Ô∏è</td><td>Interfaces for player decisions and choices</td></tr>
<tr><td>Chat System</td><td>‚ö†Ô∏è</td><td>In-game communication system</td></tr>
<tr><td>Settings Menu</td><td>‚ö†Ô∏è</td><td>Interface for adjusting game settings</td></tr>
</tbody></table>
</div>
<p>Legend:</p>
<ul>
<li>‚úÖ Implemented and tested</li>
<li>üîÑ In progress</li>
<li>‚ö†Ô∏è Planned but not yet implemented</li>
</ul>
<hr />
<p>For detailed information on specific UI components, please refer to the respective sections listed above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-ui-system-overview"><a class="header" href="#game-ui-system-overview">Game UI System Overview</a></h1>
<p>This document provides a high-level overview of the user interface system for Rummage's Commander format game. For more detailed information on specific components, please see the related documentation files.</p>
<h2 id="ui-architecture-overview"><a class="header" href="#ui-architecture-overview">UI Architecture Overview</a></h2>
<p>The Rummage game UI is built using Bevy's Entity Component System (ECS) architecture, with a clear separation of concerns between game logic and visual presentation. The UI follows a layered approach to ensure clean organization, efficient rendering, and maintainable code.</p>
<h3 id="key-components-1"><a class="header" href="#key-components-1">Key Components</a></h3>
<p>The UI system uses non-deprecated Bevy 0.15.x components:</p>
<ul>
<li><code>Node</code> for layout containers (replacing deprecated <code>NodeBundle</code>)</li>
<li><code>Text2d</code> for text display (replacing deprecated <code>Text2dBundle</code>)</li>
<li><code>Sprite</code> for images (replacing deprecated <code>SpriteBundle</code>)</li>
<li><code>Button</code> for interactive elements</li>
<li><code>RenderLayers</code> for visibility control</li>
</ul>
<h3 id="layers"><a class="header" href="#layers">Layers</a></h3>
<p>The UI architecture is organized into distinct render layers as defined in <code>src/camera/components.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash)]
pub enum AppLayer {
    #[default]
    Shared,         // Layer 0: Shared elements visible to all cameras
    Background,     // Layer 1: Game background elements
    GameWorld,      // Layer 2: Game world elements
    Cards,          // Layer 3: Card entities
    GameUI,         // Layer 4: In-game UI elements
    Effects,        // Layer 5: Visual effects
    Overlay,        // Layer 6: Game overlays
    Menu,           // Layer 7: Menu elements
    Popup,          // Layer 8: Popup dialogs
    Debug,          // Layer 9: Debug visuals
    DebugText,      // Layer 10: Debug text
    DebugGizmo,     // Layer 11: Debug gizmos
    Wireframe,      // Layer 12: Wireframe visualization
    Game = 31,      // Layer 31: Legacy game layer (backward compatibility)
}
<span class="boring">}</span></code></pre></pre>
<p>These layers enable precise control over which UI elements are visible in different game states.</p>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<p>The Rummage UI design follows these key principles:</p>
<ol>
<li><strong>Clarity First</strong>: Game state information must be clear and unambiguous</li>
<li><strong>Accessibility</strong>: UI should be usable by players with diverse accessibility needs</li>
<li><strong>Intuitive Interaction</strong>: Similar to physical Magic, but enhanced by digital capabilities</li>
<li><strong>Visual Hierarchy</strong>: Important elements stand out through size, color, and animation</li>
<li><strong>Responsive Design</strong>: Adapts to different screen sizes and orientations</li>
<li><strong>Performance</strong>: Optimized rendering for smooth gameplay</li>
</ol>
<h2 id="core-ui-systems"><a class="header" href="#core-ui-systems">Core UI Systems</a></h2>
<h3 id="1-layout-management"><a class="header" href="#1-layout-management">1. Layout Management</a></h3>
<p>The game employs a flexible layout system that organizes UI elements into zones:</p>
<ul>
<li><strong>Player Zones</strong>: Hand, battlefield, graveyard, exile, library positions</li>
<li><strong>Shared Zones</strong>: Stack, command zone, and turn structure indicators</li>
<li><strong>Information Zones</strong>: Game log, phase indicators, and supplementary information</li>
</ul>
<p>Layouts adjust dynamically based on player count, screen size, and game state.</p>
<h3 id="2-interaction-system"><a class="header" href="#2-interaction-system">2. Interaction System</a></h3>
<p>The interaction system handles:</p>
<ul>
<li><strong>Drag and Drop</strong>: Moving cards between zones, with preview of valid targets</li>
<li><strong>Targeting</strong>: Selecting targets for spells and abilities</li>
<li><strong>Context Menus</strong>: Right-click (or long press) for additional card actions</li>
<li><strong>Hotkeys</strong>: Keyboard shortcuts for common actions</li>
</ul>
<h3 id="3-state-visualization"><a class="header" href="#3-state-visualization">3. State Visualization</a></h3>
<p>The UI visualizes game state through:</p>
<ul>
<li><strong>Card Transformations</strong>: Visual representation of card states (tapped, attacking, etc.)</li>
<li><strong>Animations</strong>: Visual feedback for game events and transitions</li>
<li><strong>Effects</strong>: Particles and visual flourishes for special events</li>
</ul>
<h3 id="4-information-display"><a class="header" href="#4-information-display">4. Information Display</a></h3>
<p>Information is conveyed through:</p>
<ul>
<li><strong>Text</strong>: Game text, rules text, and reminders</li>
<li><strong>Icons</strong>: Visual representation of card types, abilities, and states</li>
<li><strong>Tooltips</strong>: Contextual help and explanations</li>
<li><strong>Game Log</strong>: Record of game events and actions</li>
</ul>
<h2 id="integration-with-game-logic"><a class="header" href="#integration-with-game-logic">Integration with Game Logic</a></h2>
<p>The UI system integrates with the game logic through:</p>
<ul>
<li><strong>Systems</strong>: Reacting to game state changes and updating visuals</li>
<li><strong>Events</strong>: Processing user interactions and converting them to game actions</li>
<li><strong>Resources</strong>: Accessing shared game state to reflect in the UI</li>
</ul>
<h2 id="technical-implementation"><a class="header" href="#technical-implementation">Technical Implementation</a></h2>
<p>The UI system is implemented using Bevy's ECS pattern:</p>
<ul>
<li><strong>Components</strong>: Define UI element properties and behaviors</li>
<li><strong>Systems</strong>: Update and render UI elements based on game state</li>
<li><strong>Resources</strong>: Store shared UI state information</li>
<li><strong>Events</strong>: Handle user input and trigger UI updates</li>
</ul>
<h2 id="accessibility-features"><a class="header" href="#accessibility-features">Accessibility Features</a></h2>
<p>The game includes several accessibility features:</p>
<ul>
<li><strong>Color Blind Modes</strong>: Alternative color schemes for color-blind players</li>
<li><strong>Text Scaling</strong>: Adjustable text size for readability</li>
<li><strong>Screen Reader Support</strong>: Critical game information is accessible via screen readers</li>
<li><strong>Keyboard Controls</strong>: Full game functionality available through keyboard</li>
<li><strong>Animation Reduction</strong>: Option to reduce or disable animations</li>
</ul>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<p>The UI system is optimized for performance through:</p>
<ul>
<li><strong>Element Pooling</strong>: Reusing UI elements to reduce allocation</li>
<li><strong>Batched Rendering</strong>: Minimizing draw calls</li>
<li><strong>Culling</strong>: Only rendering visible elements</li>
<li><strong>Async Loading</strong>: Loading assets in the background</li>
</ul>
<h2 id="future-enhancements"><a class="header" href="#future-enhancements">Future Enhancements</a></h2>
<p>Planned enhancements to the UI system include:</p>
<ul>
<li><strong>Custom Themes</strong>: Player-selectable UI themes</li>
<li><strong>UI Animations</strong>: Enhanced visual feedback</li>
<li><strong>Mobile Optimization</strong>: Touch-specific controls and layouts</li>
<li><strong>VR Mode</strong>: Virtual reality support for immersive gameplay</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-ui-layout-components"><a class="header" href="#game-ui-layout-components">Game UI Layout Components</a></h1>
<p>This document describes the layout components used in the Rummage game interface, focusing on the spatial organization and structure of the UI elements.</p>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of Contents</a></h2>
<ol>
<li><a href="game_gui/layout/playmat.html">Playmat</a></li>
<li><a href="game_gui/layout/command_zone.html">Command Zone</a></li>
<li><a href="game_gui/layout/battlefield.html">Battlefield</a></li>
<li><a href="game_gui/layout/player_zones.html">Player Zones</a></li>
<li><a href="game_gui/layout/stack.html">Stack Visualization</a></li>
<li><a href="game_gui/layout/turn_structure.html">Turn Structure UI</a></li>
</ol>
<h2 id="layout-philosophy"><a class="header" href="#layout-philosophy">Layout Philosophy</a></h2>
<p>The Rummage game layout follows these principles:</p>
<ol>
<li><strong>Spatial Clarity</strong>: Each game zone has a distinct location</li>
<li><strong>Player Symmetry</strong>: Player areas are arranged consistently</li>
<li><strong>Focus on Active Elements</strong>: Important game elements receive visual prominence</li>
<li><strong>Efficient Screen Usage</strong>: Maximize the viewing area for the battlefield</li>
<li><strong>Logical Grouping</strong>: Related UI elements are positioned near each other</li>
</ol>
<h2 id="layout-overview"><a class="header" href="#layout-overview">Layout Overview</a></h2>
<p>The game UI is structured around a central battlefield with player zones positioned around it:</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     OPPONENT INFORMATION                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ           ‚îÇ                                     ‚îÇ               ‚îÇ
‚îÇ OPPONENT  ‚îÇ                                     ‚îÇ   OPPONENT    ‚îÇ
‚îÇ EXILE     ‚îÇ                                     ‚îÇ   GRAVEYARD   ‚îÇ
‚îÇ           ‚îÇ                                     ‚îÇ               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                                     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ           ‚îÇ                                     ‚îÇ               ‚îÇ
‚îÇ           ‚îÇ                                     ‚îÇ               ‚îÇ
‚îÇ OPPONENT  ‚îÇ                                     ‚îÇ   STACK       ‚îÇ
‚îÇ LIBRARY   ‚îÇ          BATTLEFIELD                ‚îÇ   AREA        ‚îÇ
‚îÇ           ‚îÇ                                     ‚îÇ               ‚îÇ
‚îÇ           ‚îÇ                                     ‚îÇ               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                                     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ           ‚îÇ                                     ‚îÇ               ‚îÇ
‚îÇ PLAYER    ‚îÇ                                     ‚îÇ   PLAYER      ‚îÇ
‚îÇ LIBRARY   ‚îÇ                                     ‚îÇ   GRAVEYARD   ‚îÇ
‚îÇ           ‚îÇ                                     ‚îÇ               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ           ‚îÇ           PLAYER HAND               ‚îÇ   COMMAND     ‚îÇ
‚îÇ  PLAYER   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   ZONE        ‚îÇ
‚îÇ  EXILE    ‚îÇ         PLAYER INFORMATION          ‚îÇ               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<p>This layout adjusts for multiplayer games, positioning all opponents around the battlefield.</p>
<h2 id="responsive-adaptations"><a class="header" href="#responsive-adaptations">Responsive Adaptations</a></h2>
<p>The layout adapts to different screen sizes and orientations:</p>
<h3 id="desktop-layout"><a class="header" href="#desktop-layout">Desktop Layout</a></h3>
<ul>
<li>Horizontal layout with wide battlefield</li>
<li>Hand cards displayed horizontally</li>
<li>Full information displays</li>
</ul>
<h3 id="tablet-layout"><a class="header" href="#tablet-layout">Tablet Layout</a></h3>
<ul>
<li>Similar to desktop with slightly compressed zones</li>
<li>Touch-friendly spacing</li>
<li>Collapsible information panels</li>
</ul>
<h3 id="mobile-layout"><a class="header" href="#mobile-layout">Mobile Layout</a></h3>
<ul>
<li>Vertical orientation with stacked zones</li>
<li>Scrollable battlefield</li>
<li>Collapsible hand and information displays</li>
<li>Gesture-based zone navigation</li>
</ul>
<h2 id="dynamic-player-positioning"><a class="header" href="#dynamic-player-positioning">Dynamic Player Positioning</a></h2>
<p>For multiplayer games (3-4 players), the layout adjusts to position player zones around the battlefield:</p>
<h3 id="four-player-layout"><a class="header" href="#four-player-layout">Four Player Layout:</a></h3>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ‚îÇ      OPPONENT 2             ‚îÇ           ‚îÇ
‚îÇ OPPONENT2 ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ OPPONENT2 ‚îÇ
‚îÇ ZONES     ‚îÇ  ‚îÇ                       ‚îÇ  ‚îÇ ZONES     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ                       ‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ           ‚îÇ  ‚îÇ                       ‚îÇ  ‚îÇ           ‚îÇ
‚îÇ OPPONENT1 ‚îÇ  ‚îÇ                       ‚îÇ  ‚îÇ OPPONENT3 ‚îÇ
‚îÇ ZONES     ‚îÇ  ‚îÇ      BATTLEFIELD      ‚îÇ  ‚îÇ ZONES     ‚îÇ
‚îÇ           ‚îÇ  ‚îÇ                       ‚îÇ  ‚îÇ           ‚îÇ
‚îÇ           ‚îÇ  ‚îÇ                       ‚îÇ  ‚îÇ           ‚îÇ
‚îÇ           ‚îÇ  ‚îÇ                       ‚îÇ  ‚îÇ           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ                       ‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ COMMAND   ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ   STACK   ‚îÇ
‚îÇ ZONE      ‚îÇ       PLAYER ZONES          ‚îÇ   AREA    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h2 id="zone-transitions"><a class="header" href="#zone-transitions">Zone Transitions</a></h2>
<p>Zones provide visual cues during transitions:</p>
<ul>
<li><strong>Highlight</strong>: Active zones highlight during player turns</li>
<li><strong>Animation</strong>: Cards animate when moving between zones</li>
<li><strong>Focusing</strong>: Relevant zones enlarge when cards within them are targeted or selected</li>
</ul>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<p>Layout components are implemented using Bevy's UI system with nested Node components:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example layout container for a player's battlefield area
commands
    .spawn((
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(40.0),
            flex_direction: FlexDirection::Column,
            align_items: AlignItems::Center,
            justify_content: JustifyContent::Center,
            ..default()
        },
        BattlefieldContainer,
        AppLayer::GameUI.layer(),
    ))
    .with_children(|parent| {
        // Individual battlefield row containers
        // ...
    });
<span class="boring">}</span></code></pre></pre>
<h2 id="layout-managers"><a class="header" href="#layout-managers">Layout Managers</a></h2>
<p>Layout position is managed by dedicated systems that:</p>
<ol>
<li>Calculate zone positions based on player count and screen size</li>
<li>Adjust UI element scale to maintain usability</li>
<li>Reposition elements in response to game state changes</li>
<li>Handle element focus and highlighting</li>
</ol>
<p>The primary layout management systems include:</p>
<ul>
<li><code>update_layout_for_player_count</code>: Adjusts layout based on number of players</li>
<li><code>update_responsive_layout</code>: Adapts layout to screen size changes</li>
<li><code>position_cards_in_zones</code>: Manages card positioning within zones</li>
</ul>
<p>Each layout component has dedicated documentation explaining its specific implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="virtual-table-layout"><a class="header" href="#virtual-table-layout">Virtual Table Layout</a></h1>
<p>This document details the virtual table system used in Rummage for multiplayer Commander games. The table design accommodates anywhere from 2 to 6+ players while maintaining an intuitive and functional interface.</p>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of Contents</a></h2>
<ol>
<li><a href="game_gui/table/index.html#overview">Overview</a></li>
<li><a href="game_gui/table/index.html#adaptive-player-positioning">Adaptive Player Positioning</a></li>
<li><a href="game_gui/table/index.html#shared-zones">Shared Zones</a></li>
<li><a href="game_gui/table/index.html#implementation-details">Implementation Details</a></li>
<li><a href="game_gui/table/index.html#testing">Testing</a></li>
</ol>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>The virtual table serves as the central organizing element of the game UI. It:</p>
<ul>
<li>Positions players around a central battlefield</li>
<li>Scales dynamically based on player count</li>
<li>Provides appropriate space for individual and shared game zones</li>
<li>Maintains visual clarity regardless of player count</li>
</ul>
<p>The table's design simulates sitting around a physical table but takes advantage of the digital medium to maximize usability and information presentation.</p>
<h2 id="adaptive-player-positioning"><a class="header" href="#adaptive-player-positioning">Adaptive Player Positioning</a></h2>
<h3 id="player-count-configurations"><a class="header" href="#player-count-configurations">Player Count Configurations</a></h3>
<p>The table dynamically adjusts to accommodate different player counts:</p>
<h4 id="two-player-configuration"><a class="header" href="#two-player-configuration">Two Player Configuration</a></h4>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                     ‚îÇ
‚îÇ               OPPONENT PLAYMAT                      ‚îÇ
‚îÇ                                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                     ‚îÇ
‚îÇ                 SHARED AREA                         ‚îÇ
‚îÇ          (Command Zone, Stack, etc.)                ‚îÇ
‚îÇ                                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                     ‚îÇ
‚îÇ                 PLAYER PLAYMAT                      ‚îÇ
‚îÇ                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h4 id="three-player-configuration"><a class="header" href="#three-player-configuration">Three Player Configuration</a></h4>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                     ‚îÇ
‚îÇ    OPPONENT 1 PLAYMAT      OPPONENT 2 PLAYMAT       ‚îÇ
‚îÇ                                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                     ‚îÇ
‚îÇ                 SHARED AREA                         ‚îÇ
‚îÇ          (Command Zone, Stack, etc.)                ‚îÇ
‚îÇ                                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                     ‚îÇ
‚îÇ                 PLAYER PLAYMAT                      ‚îÇ
‚îÇ                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h4 id="four-player-configuration-default"><a class="header" href="#four-player-configuration-default">Four Player Configuration (Default)</a></h4>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                     ‚îÇ
‚îÇ               OPPONENT 2 PLAYMAT                    ‚îÇ
‚îÇ                                                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                ‚îÇ                ‚îÇ                  ‚îÇ
‚îÇ  OPPONENT 1    ‚îÇ  SHARED AREA   ‚îÇ   OPPONENT 3     ‚îÇ
‚îÇ   PLAYMAT      ‚îÇ (Command Zone, ‚îÇ     PLAYMAT      ‚îÇ
‚îÇ                ‚îÇ  Stack, etc.)  ‚îÇ                  ‚îÇ
‚îÇ                ‚îÇ                ‚îÇ                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                     ‚îÇ
‚îÇ                 PLAYER PLAYMAT                      ‚îÇ
‚îÇ                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h4 id="five-player-configuration"><a class="header" href="#five-player-configuration">Five+ Player Configuration</a></h4>
<p>For five or more players, the table uses a scrollable/zoomable view that arranges players in a circular pattern, with the active player and their adjacent opponents given visual priority.</p>
<h3 id="adaptive-positioning-algorithm"><a class="header" href="#adaptive-positioning-algorithm">Adaptive Positioning Algorithm</a></h3>
<p>The table employs an adaptive algorithm that:</p>
<ol>
<li>Places the local player at the bottom</li>
<li>Positions opponents based on turn order</li>
<li>Allocates screen space proportionally based on player count</li>
<li>Adjusts element scaling to maintain readability</li>
<li>Prioritizes visibility for the active player and important game elements</li>
</ol>
<h2 id="shared-zones"><a class="header" href="#shared-zones">Shared Zones</a></h2>
<p>The virtual table includes shared game zones accessible to all players:</p>
<h3 id="command-zone"><a class="header" href="#command-zone">Command Zone</a></h3>
<p>Central area for commander cards, emblems, and other command-zone specific elements.</p>
<h3 id="the-stack"><a class="header" href="#the-stack">The Stack</a></h3>
<p>Visual representation of spells and abilities currently on the stack, showing order and targeting information.</p>
<h3 id="exile-zone"><a class="header" href="#exile-zone">Exile Zone</a></h3>
<p>Shared exile area for face-up exiled cards that should be visible to all players.</p>
<h3 id="game-information-display"><a class="header" href="#game-information-display">Game Information Display</a></h3>
<p>Shows game state information such as turn number, active phase, priority holder, etc.</p>
<h2 id="implementation-details-1"><a class="header" href="#implementation-details-1">Implementation Details</a></h2>
<p>The table is implemented using Bevy's UI system with hierarchical nodes:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_virtual_table(
    mut commands: Commands,
    game_state: Res&lt;GameState&gt;,
    asset_server: Res&lt;AssetServer&gt;,
) {
    // Main table container
    commands
        .spawn((
            Node {
                width: Val::Percent(100.0),
                height: Val::Percent(100.0),
                flex_direction: FlexDirection::Column,
                ..default()
            },
            VirtualTable,
            AppLayer::GameUI.layer(),
        ))
        .with_children(|table| {
            // Layout depends on player count
            match game_state.player_count {
                2 =&gt; setup_two_player_layout(table, &amp;asset_server),
                3 =&gt; setup_three_player_layout(table, &amp;asset_server),
                4 =&gt; setup_four_player_layout(table, &amp;asset_server),
                _ =&gt; setup_many_player_layout(table, &amp;asset_server, game_state.player_count),
            }
        });
}
<span class="boring">}</span></code></pre></pre>
<h3 id="player-position-calculation"><a class="header" href="#player-position-calculation">Player Position Calculation</a></h3>
<p>Each player's position is calculated based on the total player count and their index:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Calculate angle and position for player zones based on player count
fn calculate_player_position(player_index: usize, player_count: usize) -&gt; Vec2 {
    let angle = (player_index as f32 / player_count as f32) * std::f32::consts::TAU;
    let distance = 400.0; // Distance from center
    Vec2::new(
        distance * angle.cos(),
        distance * angle.sin(),
    )
}
<span class="boring">}</span></code></pre></pre>
<h3 id="dynamic-resizing"><a class="header" href="#dynamic-resizing">Dynamic Resizing</a></h3>
<p>The table responds to window size changes, maintaining appropriate proportions:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_table_responsive_layout(
    mut query: Query&lt;&amp;mut Node, With&lt;VirtualTable&gt;&gt;,
    window: Query&lt;&amp;Window&gt;,
) {
    let window = window.single();
    let aspect_ratio = window.width() / window.height();
    
    for mut node in query.iter_mut() {
        // Adjust layout based on aspect ratio
        if aspect_ratio &gt; 1.5 {
            // Landscape orientation
            node.flex_direction = FlexDirection::Column;
        } else {
            // Portrait orientation
            node.flex_direction = FlexDirection::Row;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-2"><a class="header" href="#testing-2">Testing</a></h2>
<p>The virtual table's adaptive layout should be thoroughly tested across different scenarios:</p>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<ul>
<li>Test player position calculation for different player counts</li>
<li>Verify layout component hierarchy for each player configuration</li>
<li>Test responsive resizing behavior</li>
</ul>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<ul>
<li>Verify all player zones are visible and accessible</li>
<li>Test navigation between player areas</li>
<li>Ensure shared zones maintain visibility for all players</li>
</ul>
<h3 id="visual-tests"><a class="header" href="#visual-tests">Visual Tests</a></h3>
<ul>
<li>Confirm layout appearance across different screen sizes</li>
<li>Verify scaling behavior for UI elements</li>
<li>Test readability of cards and game information</li>
</ul>
<h3 id="performance-tests"><a class="header" href="#performance-tests">Performance Tests</a></h3>
<ul>
<li>Measure rendering performance with maximum player count</li>
<li>Test scrolling/zooming smoothness</li>
<li>Verify UI responsiveness during layout transitions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="player-playmat"><a class="header" href="#player-playmat">Player Playmat</a></h1>
<p>This document details the player playmat system in Rummage, representing each player's personal play area with all the zones required for Magic: The Gathering Commander gameplay.</p>
<h2 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of Contents</a></h2>
<ol>
<li><a href="game_gui/playmat/index.html#overview">Overview</a></li>
<li><a href="game_gui/playmat/index.html#playmat-zones">Playmat Zones</a></li>
<li><a href="game_gui/playmat/index.html#zone-interactions">Zone Interactions</a></li>
<li><a href="game_gui/playmat/index.html#adaptive-sizing">Adaptive Sizing</a></li>
<li><a href="game_gui/playmat/index.html#visual-customization">Visual Customization</a></li>
<li><a href="game_gui/playmat/index.html#implementation-details">Implementation Details</a></li>
<li><a href="game_gui/playmat/index.html#testing">Testing</a></li>
</ol>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>Each player in a Rummage game has their own playmat that:</p>
<ul>
<li>Contains all required Magic: The Gathering game zones</li>
<li>Provides clear visual separation between zones</li>
<li>Ensures cards and game elements are easily accessible</li>
<li>Adapts based on available screen space</li>
<li>Integrates with the overall virtual table layout</li>
</ul>
<h2 id="playmat-zones"><a class="header" href="#playmat-zones">Playmat Zones</a></h2>
<p>The playmat includes the following zones, as dictated by Magic: The Gathering rules:</p>
<h3 id="battlefield"><a class="header" href="#battlefield">Battlefield</a></h3>
<p>The primary play area where permanents (creatures, artifacts, enchantments, planeswalkers, lands) are placed when cast.</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                     ‚îÇ
‚îÇ                                                     ‚îÇ
‚îÇ                                                     ‚îÇ
‚îÇ                  BATTLEFIELD                        ‚îÇ
‚îÇ                                                     ‚îÇ
‚îÇ                                                     ‚îÇ
‚îÇ                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<ul>
<li>Supports tapped/untapped card states</li>
<li>Organizes cards by type (creatures, lands, etc.)</li>
<li>Allows custom grouping of permanents</li>
<li>Supports tokens and copy effects</li>
</ul>
<h3 id="hand"><a class="header" href="#hand">Hand</a></h3>
<p>The player's hand of cards, visible only to the player (and spectators with appropriate permissions).</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                     ‚îÇ
‚îÇ                      HAND                           ‚îÇ
‚îÇ                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<ul>
<li>Displays cards in a fan-out layout</li>
<li>Provides detail view on hover/select</li>
<li>Shows card count for opponents</li>
<li>Supports sorting and filtering</li>
</ul>
<h3 id="library-deck"><a class="header" href="#library-deck">Library (Deck)</a></h3>
<p>The player's library, from which they draw cards.</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ‚îÇ
‚îÇ  LIBRARY  ‚îÇ
‚îÇ           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<ul>
<li>Shows deck position and card count</li>
<li>Animates card draw and shuffle</li>
<li>Displays deck state (e.g., being searched)</li>
<li>Supports placing cards on top/bottom of library</li>
</ul>
<h3 id="graveyard"><a class="header" href="#graveyard">Graveyard</a></h3>
<p>Discard pile for cards that have been destroyed, discarded, or sacrificed.</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ‚îÇ
‚îÇ GRAVEYARD ‚îÇ
‚îÇ           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<ul>
<li>Shows most recent cards on top</li>
<li>Supports browsing full contents</li>
<li>Displays count of cards in graveyard</li>
<li>Animates cards entering the graveyard</li>
</ul>
<h3 id="exile"><a class="header" href="#exile">Exile</a></h3>
<p>Area for cards removed from the game.</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ‚îÇ
‚îÇ   EXILE   ‚îÇ
‚îÇ           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<ul>
<li>Distinguishes between face-up and face-down exiled cards</li>
<li>Groups cards by the effect that exiled them</li>
<li>Shows duration for temporary exile effects</li>
</ul>
<h3 id="command-zone-1"><a class="header" href="#command-zone-1">Command Zone</a></h3>
<p>Special zone for commander cards and emblems.</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ‚îÇ
‚îÇ  COMMAND  ‚îÇ
‚îÇ   ZONE    ‚îÇ
‚îÇ           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<ul>
<li>Prominently displays the player's commander(s)</li>
<li>Shows commander tax amount</li>
<li>Tracks commander damage given/received</li>
<li>Displays emblems and other command zone objects</li>
</ul>
<h3 id="complete-playmat-layout"><a class="header" href="#complete-playmat-layout">Complete Playmat Layout</a></h3>
<p>The full playmat integrates these zones into a cohesive layout:</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      HAND                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ           ‚îÇ                           ‚îÇ             ‚îÇ
‚îÇ  LIBRARY  ‚îÇ                           ‚îÇ  GRAVEYARD  ‚îÇ
‚îÇ           ‚îÇ                           ‚îÇ             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                           ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ           ‚îÇ                           ‚îÇ             ‚îÇ
‚îÇ           ‚îÇ       BATTLEFIELD         ‚îÇ             ‚îÇ
‚îÇ   EXILE   ‚îÇ                           ‚îÇ  COMMAND    ‚îÇ
‚îÇ           ‚îÇ                           ‚îÇ   ZONE      ‚îÇ
‚îÇ           ‚îÇ                           ‚îÇ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h2 id="zone-interactions"><a class="header" href="#zone-interactions">Zone Interactions</a></h2>
<p>The playmat facilitates several interactions between zones:</p>
<h3 id="card-movement"><a class="header" href="#card-movement">Card Movement</a></h3>
<p>Cards can move between zones through:</p>
<ul>
<li>Drag and drop gestures</li>
<li>Context menu actions</li>
<li>Keyboard shortcuts</li>
<li>Game action triggers</li>
</ul>
<p>Each movement includes appropriate animations to indicate the source and destination zones.</p>
<h3 id="zone-focus"><a class="header" href="#zone-focus">Zone Focus</a></h3>
<p>A zone can be focused to display more detailed information:</p>
<ul>
<li>Expanded graveyard view</li>
<li>Detailed hand card inspection</li>
<li>Library search views</li>
</ul>
<p>Focus interactions maintain context by showing the relationship to other zones.</p>
<h2 id="adaptive-sizing"><a class="header" href="#adaptive-sizing">Adaptive Sizing</a></h2>
<p>The playmat adapts to different screen sizes and player counts:</p>
<h3 id="size-adaptations"><a class="header" href="#size-adaptations">Size Adaptations</a></h3>
<ul>
<li><strong>Full View</strong>: When it's the player's turn or they have priority</li>
<li><strong>Compact View</strong>: During opponent turns</li>
<li><strong>Minimal View</strong>: When the player is not directly involved in the current game action</li>
</ul>
<h3 id="active-zone-emphasis"><a class="header" href="#active-zone-emphasis">Active Zone Emphasis</a></h3>
<p>The current phase of the game influences zone emphasis:</p>
<ul>
<li>During main phases, the battlefield and hand are emphasized</li>
<li>During combat, the battlefield receives more space</li>
<li>When searching library, the library zone expands</li>
</ul>
<h2 id="visual-customization"><a class="header" href="#visual-customization">Visual Customization</a></h2>
<p>Players can customize their playmat's appearance:</p>
<ul>
<li>Custom playmat backgrounds</li>
<li>Zone color themes</li>
<li>Card arrangement preferences</li>
<li>Animation settings</li>
</ul>
<h2 id="implementation-details-2"><a class="header" href="#implementation-details-2">Implementation Details</a></h2>
<p>The playmat is implemented using Bevy's UI system:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_player_playmat(
    mut commands: Commands,
    player: &amp;Player,
    asset_server: &amp;Res&lt;AssetServer&gt;,
) {
    // Main playmat container
    commands
        .spawn((
            Node {
                width: Val::Percent(100.0),
                height: Val::Percent(100.0),
                flex_direction: FlexDirection::Column,
                ..default()
            },
            PlayerPlaymat { player_id: player.id },
            AppLayer::GameUI.layer(),
        ))
        .with_children(|playmat| {
            // Hand zone
            setup_hand_zone(playmat, player, asset_server);
            
            // Middle section containing battlefield and side zones
            playmat
                .spawn(Node {
                    width: Val::Percent(100.0),
                    height: Val::Percent(80.0),
                    flex_direction: FlexDirection::Row,
                    ..default()
                })
                .with_children(|middle| {
                    // Left side zones
                    setup_left_zones(middle, player, asset_server);
                    
                    // Battlefield
                    setup_battlefield(middle, player, asset_server);
                    
                    // Right side zones
                    setup_right_zones(middle, player, asset_server);
                });
        });
}
<span class="boring">}</span></code></pre></pre>
<h3 id="zone-components"><a class="header" href="#zone-components">Zone Components</a></h3>
<p>Each zone is implemented as a component that can be queried and manipulated:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Component for the player's hand zone
#[derive(Component)]
struct HandZone {
    player_id: PlayerId,
    expanded: bool,
}

/// Component for the battlefield zone
#[derive(Component)]
struct BattlefieldZone {
    player_id: PlayerId,
    organization: BattlefieldOrganization,
}

// Other zone components follow a similar pattern
<span class="boring">}</span></code></pre></pre>
<h3 id="responsive-layout-systems"><a class="header" href="#responsive-layout-systems">Responsive Layout Systems</a></h3>
<p>Systems manage the responsive behavior of the playmat:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_playmat_layout(
    mut playmat_query: Query&lt;(&amp;mut Node, &amp;PlayerPlaymat)&gt;,
    player_turn_query: Query&lt;&amp;ActiveTurn&gt;,
    window: Query&lt;&amp;Window&gt;,
) {
    let window = window.single();
    let active_turn = player_turn_query.single();
    let is_landscape = window.width() &gt; window.height();
    
    for (mut node, playmat) in playmat_query.iter_mut() {
        let is_active_player = active_turn.player_id == playmat.player_id;
        
        // Adjust layout based on active player and orientation
        if is_active_player {
            node.height = Val::Percent(if is_landscape { 40.0 } else { 50.0 });
        } else {
            node.height = Val::Percent(if is_landscape { 20.0 } else { 25.0 });
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-3"><a class="header" href="#testing-3">Testing</a></h2>
<p>The playmat should be thoroughly tested to ensure proper functionality and visual appearance:</p>
<h3 id="unit-tests-1"><a class="header" href="#unit-tests-1">Unit Tests</a></h3>
<ul>
<li>Test correct initialization of all zones</li>
<li>Verify component hierarchy</li>
<li>Ensure proper event handling for zone interactions</li>
</ul>
<h3 id="integration-tests-1"><a class="header" href="#integration-tests-1">Integration Tests</a></h3>
<ul>
<li>Test card movement between zones</li>
<li>Verify zone focus behavior</li>
<li>Test responsive layout changes</li>
</ul>
<h3 id="visual-tests-1"><a class="header" href="#visual-tests-1">Visual Tests</a></h3>
<ul>
<li>Verify appearance across different screen sizes</li>
<li>Test with different card counts in each zone</li>
<li>Ensure readability of card information</li>
</ul>
<h3 id="gameplay-tests"><a class="header" href="#gameplay-tests">Gameplay Tests</a></h3>
<ul>
<li>Test common gameplay patterns involving multiple zones</li>
<li>Verify commander damage tracking</li>
<li>Test special zone interactions like flashback from graveyard</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="in-game-chat-system"><a class="header" href="#in-game-chat-system">In-Game Chat System</a></h1>
<p>This document details the in-game chat system in Rummage, providing communication capabilities for players during Commander format games.</p>
<h2 id="table-of-contents-5"><a class="header" href="#table-of-contents-5">Table of Contents</a></h2>
<ol>
<li><a href="game_gui/chat/index.html#overview">Overview</a></li>
<li><a href="game_gui/chat/index.html#chat-system-components">Chat System Components</a></li>
<li><a href="game_gui/chat/index.html#integration-with-game-ui">Integration With Game UI</a></li>
<li><a href="game_gui/chat/index.html#accessibility-features">Accessibility Features</a></li>
<li><a href="game_gui/chat/index.html#implementation-details">Implementation Details</a></li>
<li><a href="game_gui/chat/index.html#testing">Testing</a></li>
<li><a href="game_gui/chat/index.html#related-documentation">Related Documentation</a></li>
</ol>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>The in-game chat system provides multiple communication channels for players during gameplay:</p>
<ul>
<li><strong>Text Chat</strong>: Traditional text-based communication</li>
<li><strong>Voice Chat</strong>: Real-time audio communication</li>
<li><strong>Game Event Messages</strong>: Automated messages about game events</li>
<li><strong>Emotes and Reactions</strong>: Pre-defined expressions and reactions</li>
</ul>
<p>The chat system is designed to be non-intrusive while remaining easily accessible during gameplay, enhancing the social experience of Commander format games.</p>
<h2 id="chat-system-components"><a class="header" href="#chat-system-components">Chat System Components</a></h2>
<p>The chat system consists of several integrated components:</p>
<h3 id="text-chat"><a class="header" href="#text-chat">Text Chat</a></h3>
<p>The text chat component allows players to type and send messages to others in the game. Features include:</p>
<ul>
<li><strong>Chat Channels</strong>: Public, private, and team channels</li>
<li><strong>Message Formatting</strong>: Support for basic text formatting</li>
<li><strong>Command System</strong>: Chat commands for game actions</li>
<li><strong>Message History</strong>: Accessible chat history with search capabilities</li>
</ul>
<p><a href="game_gui/chat/text_chat.html">Detailed Text Chat Documentation</a></p>
<h3 id="voice-chat"><a class="header" href="#voice-chat">Voice Chat</a></h3>
<p>The voice chat component enables real-time audio communication between players:</p>
<ul>
<li><strong>Push-to-Talk</strong>: Configurable key binding for activating microphone</li>
<li><strong>Voice Activity Detection</strong>: Optional automatic activation based on speech</li>
<li><strong>Player Indicators</strong>: Visual cues showing who is speaking</li>
<li><strong>Individual Volume Controls</strong>: Adjust volume for specific players</li>
</ul>
<p><a href="game_gui/chat/voice_chat.html">Detailed Voice Chat Documentation</a></p>
<h3 id="game-event-messages"><a class="header" href="#game-event-messages">Game Event Messages</a></h3>
<p>Automated messages about game actions and events:</p>
<ul>
<li><strong>Stackable Notifications</strong>: Collapsible event messages</li>
<li><strong>Filtering Options</strong>: Configure which events generate messages</li>
<li><strong>Verbosity Settings</strong>: Adjust level of detail in event messages</li>
<li><strong>Highlighting</strong>: Color coding for important events</li>
</ul>
<h3 id="emotes-and-reactions"><a class="header" href="#emotes-and-reactions">Emotes and Reactions</a></h3>
<p>Quick non-verbal communication options:</p>
<ul>
<li><strong>Contextual Emotes</strong>: Reactions appropriate to game context</li>
<li><strong>Emote Wheel</strong>: Quick access to common emotes</li>
<li><strong>Custom Emotes</strong>: Limited customization options</li>
<li><strong>Cooldown System</strong>: Prevents emote spam</li>
</ul>
<h2 id="integration-with-game-ui"><a class="header" href="#integration-with-game-ui">Integration With Game UI</a></h2>
<p>The chat system integrates seamlessly with the game UI:</p>
<h3 id="chat-window-modes"><a class="header" href="#chat-window-modes">Chat Window Modes</a></h3>
<p>The chat window can appear in multiple states:</p>
<ul>
<li><strong>Expanded View</strong>: Full chat interface with history and channels</li>
<li><strong>Minimized View</strong>: Condensed view showing recent messages</li>
<li><strong>Hidden</strong>: Completely hidden with notification indicators for new messages</li>
<li><strong>Pop-out</strong>: Detachable window for multi-monitor setups</li>
</ul>
<h3 id="positioning"><a class="header" href="#positioning">Positioning</a></h3>
<p>The chat interface can be positioned in different areas:</p>
<ul>
<li><strong>Default</strong>: Bottom-left corner of the screen</li>
<li><strong>Customizable</strong>: User can reposition within constraints</li>
<li><strong>Contextual</strong>: Automatic repositioning based on game state</li>
<li><strong>Size Adjustable</strong>: Resizable chat window</li>
</ul>
<h3 id="visual-integration"><a class="header" href="#visual-integration">Visual Integration</a></h3>
<p>Visual elements that tie the chat system to the game:</p>
<ul>
<li><strong>Player Color Coding</strong>: Message colors match player identities</li>
<li><strong>Thematic Styling</strong>: Chat UI follows game's visual language</li>
<li><strong>Transition Effects</strong>: Smooth animations for state changes</li>
<li><strong>Focus Management</strong>: Proper keyboard focus handling</li>
</ul>
<h2 id="accessibility-features-1"><a class="header" href="#accessibility-features-1">Accessibility Features</a></h2>
<p>The chat system includes several accessibility features:</p>
<ul>
<li><strong>Text-to-Speech</strong>: Optional reading of incoming messages</li>
<li><strong>Speech-to-Text</strong>: Voice transcription for voice chat</li>
<li><strong>High Contrast Mode</strong>: Improved readability options</li>
<li><strong>Customizable Text Size</strong>: Adjustable font sizes</li>
<li><strong>Keyboard Navigation</strong>: Complete keyboard control</li>
<li><strong>Alternative Communication</strong>: Pre-defined phrases for quick communication</li>
<li><strong>Message Timing</strong>: Configurable message display duration</li>
</ul>
<h2 id="implementation-details-3"><a class="header" href="#implementation-details-3">Implementation Details</a></h2>
<p>The chat system is implemented using Bevy's ECS architecture:</p>
<h3 id="components"><a class="header" href="#components">Components</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Component for the chat window
#[derive(Component)]
struct ChatWindow {
    mode: ChatMode,
    active_channel: ChatChannel,
    position: ChatPosition,
    is_focused: bool,
}

/// Component for input field
#[derive(Component)]
struct ChatInput {
    text: String,
    cursor_position: usize,
    selection_range: Option&lt;(usize, usize)&gt;,
}

/// Component for chat message display
#[derive(Component)]
struct ChatMessageDisplay {
    messages: Vec&lt;ChatMessage&gt;,
    scroll_position: f32,
    filter_settings: ChatFilterSettings,
}

/// Component for voice activity
#[derive(Component)]
struct VoiceActivity {
    is_active: bool,
    volume_level: f32,
    player_id: PlayerId,
}

/// Resource for chat settings
#[derive(Resource)]
struct ChatSettings {
    text_chat_enabled: bool,
    voice_chat_enabled: bool,
    message_history_size: usize,
    notification_settings: NotificationSettings,
    accessibility_settings: ChatAccessibilitySettings,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="systems"><a class="header" href="#systems">Systems</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// System to handle incoming chat messages
fn handle_chat_messages(
    mut messages_query: Query&lt;&amp;mut ChatMessageDisplay&gt;,
    chat_events: EventReader&lt;ChatMessageEvent&gt;,
    settings: Res&lt;ChatSettings&gt;,
) {
    // Implementation
}

/// System to handle voice chat
fn process_voice_chat(
    mut voice_activity_query: Query&lt;(&amp;mut VoiceActivity, &amp;PlayerId)&gt;,
    audio_input: Res&lt;AudioInputBuffer&gt;,
    settings: Res&lt;ChatSettings&gt;,
) {
    // Implementation
}

/// System to update chat UI
fn update_chat_ui(
    mut chat_window_query: Query&lt;(&amp;mut ChatWindow, &amp;mut Node, &amp;Children)&gt;,
    keyboard_input: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
    time: Res&lt;Time&gt;,
) {
    // Implementation
}
<span class="boring">}</span></code></pre></pre>
<h3 id="chat-window-setup"><a class="header" href="#chat-window-setup">Chat Window Setup</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Setup the chat window
fn setup_chat_window(
    mut commands: Commands,
    asset_server: Res&lt;AssetServer&gt;,
    chat_settings: Res&lt;ChatSettings&gt;,
) {
    // Main chat container
    commands
        .spawn((
            ChatWindow {
                mode: ChatMode::Minimized,
                active_channel: ChatChannel::Global,
                position: ChatPosition::BottomLeft,
                is_focused: false,
            },
            Node {
                width: Val::Px(400.0),
                height: Val::Px(300.0),
                position_type: PositionType::Absolute,
                bottom: Val::Px(10.0),
                left: Val::Px(10.0),
                flex_direction: FlexDirection::Column,
                ..default()
            },
            BackgroundColor(Color::rgba(0.1, 0.1, 0.1, 0.8)),
            BorderColor(Color::rgb(0.3, 0.3, 0.3)),
            Outline::new(Val::Px(1.0)),
            AppLayer::GameUI.layer(),
            Visibility::Visible,
        ))
        .with_children(|parent| {
            // Chat header
            setup_chat_header(parent, &amp;asset_server);
            
            // Message display area
            setup_message_display(parent, &amp;asset_server);
            
            // Chat input area
            setup_chat_input(parent, &amp;asset_server);
            
            // Voice chat indicators
            if chat_settings.voice_chat_enabled {
                setup_voice_indicators(parent, &amp;asset_server);
            }
        });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-4"><a class="header" href="#testing-4">Testing</a></h2>
<p>The chat system requires thorough testing to ensure reliability and performance:</p>
<h3 id="unit-tests-2"><a class="header" href="#unit-tests-2">Unit Tests</a></h3>
<ul>
<li>Test message processing</li>
<li>Verify channel functionality</li>
<li>Test input handling</li>
<li>Validate filtering systems</li>
</ul>
<h3 id="integration-tests-2"><a class="header" href="#integration-tests-2">Integration Tests</a></h3>
<ul>
<li>Test chat integration with game events</li>
<li>Verify voice chat synchronization</li>
<li>Test accessibility features</li>
<li>Validate UI responsiveness</li>
</ul>
<h3 id="performance-tests-1"><a class="header" href="#performance-tests-1">Performance Tests</a></h3>
<ul>
<li>Test with high message volume</li>
<li>Measure voice chat latency</li>
<li>Verify memory usage with large chat history</li>
<li>Test network bandwidth usage</li>
</ul>
<h3 id="usability-tests"><a class="header" href="#usability-tests">Usability Tests</a></h3>
<ul>
<li>Validate readability</li>
<li>Test keyboard navigation</li>
<li>Verify mobile touch interactions</li>
<li>Test with screen readers</li>
</ul>
<h2 id="related-documentation"><a class="header" href="#related-documentation">Related Documentation</a></h2>
<ul>
<li><a href="game_gui/chat/text_chat.html">Text Chat Details</a></li>
<li><a href="game_gui/chat/voice_chat.html">Voice Chat Details</a></li>
<li><a href="game_gui/chat/chat_api.html">Chat API for Plugins</a></li>
<li><a href="game_gui/chat/network_protocol.html">Network Protocol for Chat</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="player-avatars"><a class="header" href="#player-avatars">Player Avatars</a></h1>
<p>This document describes the player avatar system in Rummage, which provides visual representation of players in the game interface.</p>
<h2 id="table-of-contents-6"><a class="header" href="#table-of-contents-6">Table of Contents</a></h2>
<ol>
<li><a href="game_gui/avatar/index.html#overview">Overview</a></li>
<li><a href="game_gui/avatar/index.html#avatar-components">Avatar Components</a></li>
<li><a href="game_gui/avatar/index.html#visual-representation">Visual Representation</a></li>
<li><a href="game_gui/avatar/index.html#player-state-indicators">Player State Indicators</a></li>
<li><a href="game_gui/avatar/index.html#customization">Customization</a></li>
<li><a href="game_gui/avatar/index.html#implementation-details">Implementation Details</a></li>
<li><a href="game_gui/avatar/index.html#testing">Testing</a></li>
</ol>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>The avatar system provides a visual representation of each player in the Commander game. Avatars help players:</p>
<ul>
<li>Quickly identify who controls which game elements</li>
<li>See player status information at a glance</li>
<li>Express identity through customization</li>
<li>Visualize social interactions and game effects</li>
</ul>
<h2 id="avatar-components"><a class="header" href="#avatar-components">Avatar Components</a></h2>
<p>Each player avatar consists of multiple visual components:</p>
<h3 id="core-components"><a class="header" href="#core-components">Core Components</a></h3>
<ul>
<li><strong>Profile Picture</strong>: The primary visual identity of the player</li>
<li><strong>Name Plate</strong>: Displays the player's username</li>
<li><strong>Life Counter</strong>: Shows current life total with emphasis on changes</li>
<li><strong>Priority Indicator</strong>: Shows when a player has priority</li>
<li><strong>Turn Indicator</strong>: Highlights the active player</li>
<li><strong>Commander Damage Tracker</strong>: Displays commander damage received from each opponent</li>
</ul>
<h3 id="example-avatar-layout"><a class="header" href="#example-avatar-layout">Example Avatar Layout</a></h3>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   Username               ‚îÇ
‚îÇ  ‚îÇ      ‚îÇ   Life: 40 ‚ñ≤2            ‚îÇ
‚îÇ  ‚îÇ IMG  ‚îÇ                          ‚îÇ
‚îÇ  ‚îÇ      ‚îÇ   ‚ö° Priority             ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ CMD DMG: P1(0) P2(6) P3(0) P4(0)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h2 id="visual-representation"><a class="header" href="#visual-representation">Visual Representation</a></h2>
<p>Avatars appear in different locations depending on the context:</p>
<h3 id="in-game-placement"><a class="header" href="#in-game-placement">In-Game Placement</a></h3>
<ul>
<li><strong>Local Player</strong>: Usually positioned at the bottom of the screen</li>
<li><strong>Opponents</strong>: Positioned around the virtual table based on turn order</li>
<li><strong>Active Player</strong>: Receives visual emphasis through highlighting or scaling</li>
</ul>
<h3 id="avatar-sizing"><a class="header" href="#avatar-sizing">Avatar Sizing</a></h3>
<p>Avatars adapt to different contexts:</p>
<ul>
<li><strong>Full Size</strong>: In player information panels</li>
<li><strong>Medium Size</strong>: At the head of playmat areas</li>
<li><strong>Small Size</strong>: Near cards to indicate control</li>
<li><strong>Minimal</strong>: In chat and notification areas</li>
</ul>
<h2 id="player-state-indicators"><a class="header" href="#player-state-indicators">Player State Indicators</a></h2>
<p>Avatars reflect player state through visual cues:</p>
<h3 id="game-state-indicators"><a class="header" href="#game-state-indicators">Game State Indicators</a></h3>
<ul>
<li><strong>Turn Status</strong>: Highlight for active player</li>
<li><strong>Priority Status</strong>: Indicator when player has priority</li>
<li><strong>Thinking Status</strong>: Animation when player is taking an action</li>
<li><strong>Passed Status</strong>: Indicator when player has passed priority</li>
</ul>
<h3 id="player-status-indicators"><a class="header" href="#player-status-indicators">Player Status Indicators</a></h3>
<ul>
<li><strong>Life Total</strong>: Shows current life with animations for changes</li>
<li><strong>Hand Size</strong>: Indicates number of cards in hand</li>
<li><strong>Disconnected Status</strong>: Indicator for disconnected players</li>
<li><strong>Away Status</strong>: Indicator for temporarily inactive players</li>
</ul>
<h3 id="hand-status-indicators"><a class="header" href="#hand-status-indicators">Hand Status Indicators</a></h3>
<ul>
<li><strong>Card Count</strong>: Shows number of cards in hand</li>
<li><strong>Mulligan Status</strong>: Indicates if player is mulliganing</li>
<li><strong>Drawing Status</strong>: Animation when drawing cards</li>
</ul>
<h2 id="customization"><a class="header" href="#customization">Customization</a></h2>
<p>Players can customize their avatars to express identity:</p>
<h3 id="visual-customization-1"><a class="header" href="#visual-customization-1">Visual Customization</a></h3>
<ul>
<li><strong>Profile Pictures</strong>: Select from built-in options or upload custom images</li>
<li><strong>Borders</strong>: Decorative frames around profile pictures</li>
<li><strong>Effects</strong>: Special visual effects for achievements or rankings</li>
<li><strong>Color Schemes</strong>: Customize colors of avatar UI elements</li>
</ul>
<h3 id="indicator-customization"><a class="header" href="#indicator-customization">Indicator Customization</a></h3>
<ul>
<li><strong>Life Counter Style</strong>: Different visualization styles</li>
<li><strong>Animation Types</strong>: Preference for animation effects</li>
<li><strong>Sound Effects</strong>: Custom sounds for avatar-related events</li>
</ul>
<h2 id="implementation-details-4"><a class="header" href="#implementation-details-4">Implementation Details</a></h2>
<p>Avatars are implemented using Bevy's ECS system:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Component for player avatars
#[derive(Component)]
struct PlayerAvatar {
    player_id: PlayerId,
    display_name: String,
    profile_image: Handle&lt;Image&gt;,
    border_style: AvatarBorderStyle,
    customization_settings: AvatarCustomization,
}

/// Component for avatar life counter display
#[derive(Component)]
struct AvatarLifeCounter {
    player_id: PlayerId,
    current_life: i32,
    previous_life: i32,
    animation_timer: Timer,
    is_animating: bool,
}

/// Setup function for player avatars
fn setup_player_avatar(
    mut commands: Commands,
    player: &amp;Player,
    asset_server: &amp;Res&lt;AssetServer&gt;,
    position: Vec2,
) -&gt; Entity {
    // Default profile image
    let profile_image = player.profile_image.clone()
        .unwrap_or_else(|| asset_server.load("textures/avatars/default.png"));
    
    commands
        .spawn((
            PlayerAvatar {
                player_id: player.id,
                display_name: player.name.clone(),
                profile_image: profile_image.clone(),
                border_style: AvatarBorderStyle::default(),
                customization_settings: player.avatar_customization.clone(),
            },
            Node {
                width: Val::Px(280.0),
                height: Val::Px(80.0),
                flex_direction: FlexDirection::Row,
                padding: UiRect::all(Val::Px(5.0)),
                ..default()
            },
            BackgroundColor(Color::rgba(0.1, 0.1, 0.1, 0.8)),
            BorderColor(Color::rgb(0.6, 0.6, 0.6)),
            Outline::new(Val::Px(1.0)),
            Transform::from_translation(Vec3::new(position.x, position.y, 0.0)),
            GlobalTransform::default(),
            AppLayer::GameUI.layer(),
        ))
        .with_children(|parent| {
            // Profile image container
            parent
                .spawn(Node {
                    width: Val::Px(70.0),
                    height: Val::Px(70.0),
                    margin: UiRect::right(Val::Px(10.0)),
                    ..default()
                })
                .with_children(|image_container| {
                    // Profile image
                    image_container.spawn((
                        Sprite {
                            custom_size: Some(Vec2::new(70.0, 70.0)),
                            ..default()
                        },
                        profile_image,
                    ));
                });
            
            // Information container
            parent
                .spawn(Node {
                    width: Val::Percent(100.0),
                    height: Val::Percent(100.0),
                    flex_direction: FlexDirection::Column,
                    justify_content: JustifyContent::SpaceBetween,
                    ..default()
                })
                .with_children(|info| {
                    // Username
                    info.spawn((
                        Text2d {
                            text: player.name.clone(),
                            font_size: 18.0,
                            color: Color::WHITE,
                        },
                    ));
                    
                    // Life counter
                    info.spawn((
                        Text2d {
                            text: format!("Life: {}", player.life),
                            font_size: 16.0,
                            color: Color::rgb(0.8, 0.8, 0.8),
                        },
                        AvatarLifeCounter {
                            player_id: player.id,
                            current_life: player.life,
                            previous_life: player.life,
                            animation_timer: Timer::from_seconds(0.5, TimerMode::Once),
                            is_animating: false,
                        },
                    ));
                    
                    // Priority indicator (hidden by default)
                    info.spawn((
                        Text2d {
                            text: "‚ö° Priority".to_string(),
                            font_size: 16.0,
                            color: Color::YELLOW,
                        },
                        PriorityIndicator { 
                            player_id: player.id, 
                            visible: false 
                        },
                        Visibility::Hidden,
                    ));
                });
        })
        .id()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="life-total-update-system"><a class="header" href="#life-total-update-system">Life Total Update System</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_avatar_life_counters(
    time: Res&lt;Time&gt;,
    mut life_counter_query: Query&lt;(&amp;mut AvatarLifeCounter, &amp;mut Text2d)&gt;,
    player_query: Query&lt;(&amp;Player, &amp;PlayerId)&gt;,
) {
    for (player, player_id) in player_query.iter() {
        for (mut life_counter, mut text) in life_counter_query.iter_mut() {
            if life_counter.player_id == *player_id {
                // Check if life has changed
                if player.life != life_counter.current_life {
                    // Update previous life for animation
                    life_counter.previous_life = life_counter.current_life;
                    life_counter.current_life = player.life;
                    life_counter.is_animating = true;
                    life_counter.animation_timer.reset();
                }
                
                // Update text display
                if life_counter.is_animating {
                    life_counter.animation_timer.tick(time.delta());
                    
                    // Determine color based on life change
                    let life_change = life_counter.current_life - life_counter.previous_life;
                    let color = if life_change &gt; 0 {
                        Color::GREEN
                    } else if life_change &lt; 0 {
                        Color::RED
                    } else {
                        Color::WHITE
                    };
                    
                    // Format text with change indicator
                    let change_text = if life_change &gt; 0 {
                        format!("‚ñ≤{}", life_change)
                    } else if life_change &lt; 0 {
                        format!("‚ñº{}", life_change.abs())
                    } else {
                        String::new()
                    };
                    
                    text.text = format!("Life: {} {}", life_counter.current_life, change_text);
                    text.color = color;
                    
                    // End animation after timer completes
                    if life_counter.animation_timer.finished() {
                        life_counter.is_animating = false;
                        text.color = Color::WHITE;
                        text.text = format!("Life: {}", life_counter.current_life);
                    }
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="priority-indicator-system"><a class="header" href="#priority-indicator-system">Priority Indicator System</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_priority_indicators(
    mut priority_query: Query&lt;(&amp;mut Visibility, &amp;PriorityIndicator)&gt;,
    game_state: Res&lt;GameState&gt;,
) {
    // Find player with priority
    let priority_player_id = game_state.priority_player;
    
    // Update all priority indicators
    for (mut visibility, indicator) in priority_query.iter_mut() {
        if indicator.player_id == priority_player_id {
            *visibility = Visibility::Visible;
        } else {
            *visibility = Visibility::Hidden;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-5"><a class="header" href="#testing-5">Testing</a></h2>
<p>The avatar system should be thoroughly tested to ensure proper functionality and visual appearance.</p>
<h3 id="unit-tests-3"><a class="header" href="#unit-tests-3">Unit Tests</a></h3>
<ul>
<li>Test initialization with different player data</li>
<li>Verify life counter updates correctly</li>
<li>Ensure priority indicators toggle correctly</li>
<li>Test avatar positioning logic</li>
</ul>
<h3 id="visual-tests-2"><a class="header" href="#visual-tests-2">Visual Tests</a></h3>
<ul>
<li>Verify appearance across different screen sizes</li>
<li>Test with varied life totals</li>
<li>Verify animations for life changes</li>
<li>Ensure visibility of all avatar elements</li>
</ul>
<h3 id="integration-tests-3"><a class="header" href="#integration-tests-3">Integration Tests</a></h3>
<ul>
<li>Test avatar updates with game state changes</li>
<li>Verify commander damage display updates correctly</li>
<li>Test avatar interactions with turn system</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-ui-testing-guide"><a class="header" href="#game-ui-testing-guide">Game UI Testing Guide</a></h1>
<p>This document outlines testing strategies and methodologies for Rummage's game UI system, with a focus on ensuring stability, correctness, and usability across different scenarios.</p>
<h2 id="table-of-contents-7"><a class="header" href="#table-of-contents-7">Table of Contents</a></h2>
<ol>
<li><a href="game_gui/testing/index.html#testing-philosophy">Testing Philosophy</a></li>
<li><a href="game_gui/testing/index.html#unit-testing">Unit Testing</a></li>
<li><a href="game_gui/testing/index.html#integration-testing">Integration Testing</a></li>
<li><a href="game_gui/testing/index.html#visual-regression-testing">Visual Regression Testing</a></li>
<li><a href="game_gui/testing/index.html#performance-testing">Performance Testing</a></li>
<li><a href="game_gui/testing/index.html#accessibility-testing">Accessibility Testing</a></li>
<li><a href="game_gui/testing/index.html#automation-framework">Automation Framework</a></li>
<li><a href="game_gui/testing/index.html#test-case-organization">Test Case Organization</a></li>
</ol>
<h2 id="testing-philosophy"><a class="header" href="#testing-philosophy">Testing Philosophy</a></h2>
<p>The UI testing approach for Rummage follows these core principles:</p>
<ol>
<li><strong>Comprehensive Coverage</strong>: Test all UI components across different configurations</li>
<li><strong>Behavior-Driven</strong>: Focus on testing functionality from a user perspective</li>
<li><strong>Automated Where Possible</strong>: Leverage automation for regression testing</li>
<li><strong>Visual Correctness</strong>: Ensure visual elements appear as designed</li>
<li><strong>Performance Aware</strong>: Verify UI performs well under different conditions</li>
</ol>
<h2 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h2>
<p>Unit tests focus on testing individual UI components in isolation.</p>
<h3 id="component-testing"><a class="header" href="#component-testing">Component Testing</a></h3>
<p>Test each UI component separately to verify:</p>
<ul>
<li>Correct initialization</li>
<li>Proper event handling</li>
<li>State transitions</li>
<li>Component lifecycle behaviors</li>
</ul>
<p>Example test for a component:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_hand_zone_initialization() {
    // Create app with test plugins
    let mut app = App::new();
    app.add_plugins(MinimalPlugins)
       .add_systems(Update, ui_systems::update_hand_zone);
    
    // Setup test state
    let player_id = PlayerId(1);
    let test_cards = vec![
        Card::new("Test Card 1"),
        Card::new("Test Card 2"),
        Card::new("Test Card 3"),
    ];
    
    // Spawn hand zone with test cards
    app.world.spawn((
        HandZone { player_id, expanded: false },
        Node {
            width: Val::Percent(100.0),
            height: Val::Px(200.0),
            ..default()
        },
    ));
    
    // Add cards to player's hand
    let hand = Hand { cards: test_cards, player_id };
    app.world.insert_resource(hand);
    
    // Run systems
    app.update();
    
    // Verify hand zone contains correct number of card entities
    let hand_entity = app.world.query_filtered::&lt;Entity, With&lt;HandZone&gt;&gt;().single(&amp;app.world);
    let children = app.world.get::&lt;Children&gt;(hand_entity).unwrap();
    assert_eq!(children.len(), 3, "Hand zone should contain 3 card entities");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="event-handling-tests"><a class="header" href="#event-handling-tests">Event Handling Tests</a></h3>
<p>Test that UI components respond correctly to events:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_card_drag_event_handling() {
    // Create test app
    let mut app = App::new();
    app.add_plugins(MinimalPlugins)
       .add_event::&lt;CardDragStartEvent&gt;()
       .add_event::&lt;CardDragEndEvent&gt;()
       .add_systems(Update, ui_systems::handle_card_drag_events);
    
    // Set up test entities
    let card_entity = app.world.spawn(Card::new("Test Card")).id();
    
    // Trigger drag start event
    app.world.send_event(CardDragStartEvent {
        card_entity,
        cursor_position: Vec2::new(100.0, 100.0),
    });
    
    // Run systems
    app.update();
    
    // Verify card is being dragged
    let dragging = app.world.get::&lt;Dragging&gt;(card_entity).unwrap();
    assert!(dragging.active, "Card should be in dragging state");
    
    // Trigger drag end event
    app.world.send_event(CardDragEndEvent {
        card_entity,
        cursor_position: Vec2::new(200.0, 200.0),
    });
    
    // Run systems
    app.update();
    
    // Verify card is no longer being dragged
    assert!(app.world.get::&lt;Dragging&gt;(card_entity).is_none(), "Dragging component should be removed");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="layout-tests"><a class="header" href="#layout-tests">Layout Tests</a></h3>
<p>Verify that UI layout components arrange children correctly:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_battlefield_layout() {
    // Create test app
    let mut app = App::new();
    app.add_plugins(MinimalPlugins)
       .add_systems(Update, ui_systems::position_battlefield_cards);
    
    // Set up battlefield entity with cards
    let battlefield_entity = app.world.spawn((
        BattlefieldZone {
            player_id: PlayerId(1),
            organization: BattlefieldOrganization::ByType,
        },
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(100.0),
            ..default()
        },
        Transform::default(),
        GlobalTransform::default(),
    )).id();
    
    // Add some test cards to the battlefield
    let card_entities = (0..5).map(|i| {
        let card_entity = app.world.spawn((
            Card::new(&amp;format!("Test Card {}", i)),
            CardType::Creature,
            Transform::default(),
            GlobalTransform::default(),
            Parent(battlefield_entity),
        )).id();
        app.world.entity_mut(battlefield_entity).add_child(card_entity);
        card_entity
    }).collect::&lt;Vec&lt;_&gt;&gt;();
    
    // Run systems
    app.update();
    
    // Verify cards are positioned correctly
    for (i, card_entity) in card_entities.iter().enumerate() {
        let transform = app.world.get::&lt;Transform&gt;(*card_entity).unwrap();
        // Cards should be arranged in a row with spacing
        assert_approx_eq!(transform.translation.x, i as f32 * 120.0, 1.0);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h2>
<p>Integration tests verify that multiple UI components work together correctly.</p>
<h3 id="playmat-integration-tests"><a class="header" href="#playmat-integration-tests">Playmat Integration Tests</a></h3>
<p>Test that all zones in a player's playmat interact correctly:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_card_movement_between_zones() {
    // Create test app
    let mut app = App::new();
    app.add_plugins(GameUiTestPlugins)
       .add_systems(Update, (
           ui_systems::handle_card_movement,
           ui_systems::update_zones,
       ));
    
    // Set up test player and playmat
    let player_id = PlayerId(1);
    setup_test_playmat(&amp;mut app, player_id);
    
    // Get zone entities
    let hand_entity = app.world.query_filtered::&lt;Entity, With&lt;HandZone&gt;&gt;().single(&amp;app.world);
    let battlefield_entity = app.world.query_filtered::&lt;Entity, With&lt;BattlefieldZone&gt;&gt;().single(&amp;app.world);
    
    // Create test card in hand
    let card_entity = app.world.spawn((
        Card::new("Test Creature"),
        CardType::Creature,
        Transform::default(),
        GlobalTransform::default(),
        Parent(hand_entity),
        InZone::Hand,
    )).id();
    app.world.entity_mut(hand_entity).add_child(card_entity);
    
    // Simulate playing card from hand to battlefield
    app.world.send_event(PlayCardEvent {
        card_entity,
        source_zone: Zone::Hand,
        destination_zone: Zone::Battlefield,
        player_id,
    });
    
    // Run systems
    app.update();
    
    // Verify card moved to battlefield
    let card_parent = app.world.get::&lt;Parent&gt;(card_entity).unwrap();
    assert_eq!(card_parent.get(), battlefield_entity, "Card should be in battlefield");
    
    let in_zone = app.world.get::&lt;InZone&gt;(card_entity).unwrap();
    assert_eq!(*in_zone, InZone::Battlefield, "Card zone should be Battlefield");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="table-integration-tests"><a class="header" href="#table-integration-tests">Table Integration Tests</a></h3>
<p>Test the entire table layout with multiple players:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_four_player_table_layout() {
    // Create test app
    let mut app = App::new();
    app.add_plugins(GameUiTestPlugins)
       .add_systems(Update, ui_systems::update_table_layout);
    
    // Set up game state with 4 players
    let mut game_state = GameState::default();
    game_state.player_count = 4;
    app.world.insert_resource(game_state);
    
    // Set up virtual table
    let table_entity = app.world.spawn((
        VirtualTable,
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(100.0),
            ..default()
        },
    )).id();
    
    // Trigger table setup
    app.world.send_event(SetupTableEvent { player_count: 4 });
    
    // Run systems
    app.update();
    
    // Verify table has correct structure for 4 players
    let children = app.world.get::&lt;Children&gt;(table_entity).unwrap();
    
    // Should have 5 children: 4 player playmats + shared area
    assert_eq!(children.len(), 5, "Table should have 5 main areas for 4 players");
    
    // Verify each player's playmat exists and has correct position
    let playmat_query = app.world.query_filtered::&lt;(&amp;PlayerPlaymat, &amp;Node), With&lt;Node&gt;&gt;();
    assert_eq!(playmat_query.iter(&amp;app.world).count(), 4, "Should have 4 player playmats");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="ui-flow-tests"><a class="header" href="#ui-flow-tests">UI Flow Tests</a></h3>
<p>Test complete UI workflows from start to finish:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_cast_spell_targeting_ui_flow() {
    // Create test app
    let mut app = App::new();
    app.add_plugins(GameUiTestPlugins)
       .add_systems(Update, (
           ui_systems::handle_card_selection,
           ui_systems::handle_targeting,
           ui_systems::update_stack_visualization,
       ));
    
    // Set up game with 2 players
    setup_test_game(&amp;mut app, 2);
    
    // Get player hand and opponent battlefield
    let player_id = PlayerId(1);
    let opponent_id = PlayerId(2);
    let hand_entity = get_player_zone_entity(&amp;app, player_id, ZoneType::Hand);
    let opp_battlefield_entity = get_player_zone_entity(&amp;app, opponent_id, ZoneType::Battlefield);
    
    // Add test spell to player's hand
    let spell_entity = app.world.spawn((
        Card::new("Test Lightning Bolt"),
        CardType::Instant,
        RequiresTarget { valid_targets: TargetType::CreatureOrPlayer },
        Transform::default(),
        GlobalTransform::default(),
        Parent(hand_entity),
        InZone::Hand,
    )).id();
    app.world.entity_mut(hand_entity).add_child(spell_entity);
    
    // Add creature to opponent's battlefield
    let creature_entity = app.world.spawn((
        Card::new("Test Creature"),
        CardType::Creature,
        Transform::default(),
        GlobalTransform::default(),
        Parent(opp_battlefield_entity),
        InZone::Battlefield,
    )).id();
    app.world.entity_mut(opp_battlefield_entity).add_child(creature_entity);
    
    // Simulate spell cast
    app.world.send_event(CardSelectedEvent {
        card_entity: spell_entity,
        player_id,
    });
    app.update();
    
    // Verify targeting mode is active
    let ui_state = app.world.resource::&lt;UiState&gt;();
    assert_eq!(ui_state.mode, UiMode::Targeting, "UI should be in targeting mode");
    
    // Simulate target selection
    app.world.send_event(TargetSelectedEvent {
        source_entity: spell_entity,
        target_entity: creature_entity,
        player_id,
    });
    app.update();
    
    // Verify spell is on stack
    let stack_entity = app.world.query_filtered::&lt;Entity, With&lt;StackZone&gt;&gt;().single(&amp;app.world);
    let stack_children = app.world.get::&lt;Children&gt;(stack_entity).unwrap();
    assert!(!stack_children.is_empty(), "Stack should contain the cast spell");
    
    // Verify targeting visualization
    let targeting = app.world.query_filtered::&lt;&amp;TargetingVisualization, With&lt;TargetingVisualization&gt;&gt;().single(&amp;app.world);
    assert_eq!(targeting.source, spell_entity);
    assert_eq!(targeting.target, creature_entity);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="visual-regression-testing"><a class="header" href="#visual-regression-testing">Visual Regression Testing</a></h2>
<p>Visual tests verify that UI components appear correctly.</p>
<h3 id="screenshot-comparison-tests"><a class="header" href="#screenshot-comparison-tests">Screenshot Comparison Tests</a></h3>
<p>Compare screenshots of UI elements against reference images:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_card_appearance() {
    // Create test app
    let mut app = App::new();
    app.add_plugins(VisualTestPlugins)
       .add_systems(Update, ui_systems::render_card);
    
    // Set up test card
    let card = Card::new("Test Card");
    card.card_type = CardType::Creature;
    card.mana_cost = "2R".into();
    
    app.world.spawn((
        card,
        Transform::from_xyz(400.0, 300.0, 0.0),
        GlobalTransform::default(),
    ));
    
    // Render frame
    app.update();
    
    // Take screenshot
    let screenshot = take_screenshot(&amp;app);
    
    // Compare with reference image
    let reference = load_reference_image("card_appearance.png");
    let difference = compare_images(&amp;screenshot, &amp;reference);
    
    assert!(difference &lt; 0.01, "Card appearance doesn't match reference");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="layout-verification-tests"><a class="header" href="#layout-verification-tests">Layout Verification Tests</a></h3>
<p>Verify layout properties of UI elements:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_playmat_layout_proportions() {
    // Create test app
    let mut app = App::new();
    app.add_plugins(GameUiTestPlugins);
    
    // Set up test playmat
    setup_test_playmat(&amp;mut app, PlayerId(1));
    
    // Run systems
    app.update();
    
    // Query zone entities
    let hand_query = app.world.query_filtered::&lt;&amp;Node, With&lt;HandZone&gt;&gt;();
    let battlefield_query = app.world.query_filtered::&lt;&amp;Node, With&lt;BattlefieldZone&gt;&gt;();
    
    // Verify hand zone height
    let hand_node = hand_query.single(&amp;app.world);
    match hand_node.height {
        Val::Percent(percent) =&gt; {
            assert!(percent &gt; 15.0 &amp;&amp; percent &lt; 25.0, "Hand zone height should be ~20%");
        },
        _ =&gt; panic!("Hand height should be a percentage"),
    }
    
    // Verify battlefield zone height
    let battlefield_node = battlefield_query.single(&amp;app.world);
    match battlefield_node.height {
        Val::Percent(percent) =&gt; {
            assert!(percent &gt; 50.0 &amp;&amp; percent &lt; 70.0, "Battlefield height should be ~60%");
        },
        _ =&gt; panic!("Battlefield height should be a percentage"),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<p>Performance tests verify that the UI performs well under different conditions.</p>
<h3 id="card-volume-tests"><a class="header" href="#card-volume-tests">Card Volume Tests</a></h3>
<p>Test UI performance with large numbers of cards:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_battlefield_performance_with_many_cards() {
    // Create test app
    let mut app = App::new();
    app.add_plugins(GameUiTestPlugins)
       .add_plugins(DiagnosticsPlugin);
    
    // Set up battlefield with many cards
    let battlefield_entity = app.world.spawn((
        BattlefieldZone {
            player_id: PlayerId(1),
            organization: BattlefieldOrganization::ByType,
        },
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(100.0),
            ..default()
        },
    )).id();
    
    // Add 100 test cards to the battlefield
    for i in 0..100 {
        let card_entity = app.world.spawn((
            Card::new(&amp;format!("Test Card {}", i)),
            CardType::Creature,
            Transform::default(),
            GlobalTransform::default(),
        )).id();
        app.world.entity_mut(battlefield_entity).add_child(card_entity);
    }
    
    // Run performance test
    let mut frame_times = Vec::new();
    for _ in 0..100 {
        let start = std::time::Instant::now();
        app.update();
        frame_times.push(start.elapsed());
    }
    
    // Calculate average frame time
    let avg_frame_time = frame_times.iter().sum::&lt;std::time::Duration&gt;() / frame_times.len() as u32;
    
    // Average frame time should be under 16ms (60fps)
    assert!(avg_frame_time.as_millis() &lt; 16, "UI is not performing well with many cards");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="animation-performance-tests"><a class="header" href="#animation-performance-tests">Animation Performance Tests</a></h3>
<p>Test performance of UI animations:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_card_draw_animation_performance() {
    // Create test app
    let mut app = App::new();
    app.add_plugins(GameUiTestPlugins)
       .add_plugins(DiagnosticsPlugin);
    
    // Set up player zones
    setup_test_playmat(&amp;mut app, PlayerId(1));
    
    // Get zone entities
    let library_entity = app.world.query_filtered::&lt;Entity, With&lt;LibraryZone&gt;&gt;().single(&amp;app.world);
    let hand_entity = app.world.query_filtered::&lt;Entity, With&lt;HandZone&gt;&gt;().single(&amp;app.world);
    
    // Set up library with cards
    for i in 0..50 {
        let card_entity = app.world.spawn((
            Card::new(&amp;format!("Library Card {}", i)),
            Transform::default(),
            GlobalTransform::default(),
            Parent(library_entity),
            InZone::Library,
        )).id();
        app.world.entity_mut(library_entity).add_child(card_entity);
    }
    
    // Measure performance while drawing multiple cards
    let mut frame_times = Vec::new();
    for i in 0..7 {
        // Draw a card
        let card_entity = app.world.query_filtered::&lt;Entity, (With&lt;Card&gt;, With&lt;InZone&gt;)&gt;()
            .iter(&amp;app.world)
            .next()
            .unwrap();
            
        app.world.send_event(DrawCardEvent {
            player_id: PlayerId(1),
            card_entity,
        });
        
        // Run update and measure frame time
        let start = std::time::Instant::now();
        app.update();
        frame_times.push(start.elapsed());
    }
    
    // Calculate average and maximum frame time
    let avg_frame_time = frame_times.iter().sum::&lt;std::time::Duration&gt;() / frame_times.len() as u32;
    let max_frame_time = frame_times.iter().max().unwrap();
    
    // Performance assertions
    assert!(avg_frame_time.as_millis() &lt; 16, "Card draw animation average performance is too slow");
    assert!(max_frame_time.as_millis() &lt; 32, "Card draw animation maximum frame time is too slow");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="accessibility-testing"><a class="header" href="#accessibility-testing">Accessibility Testing</a></h2>
<p>Tests to verify UI accessibility features.</p>
<h3 id="color-blind-mode-tests"><a class="header" href="#color-blind-mode-tests">Color Blind Mode Tests</a></h3>
<p>Test that UI is usable in color blind modes:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_color_blind_mode_card_distinction() {
    // Create test app
    let mut app = App::new();
    app.add_plugins(GameUiTestPlugins);
    
    // Set accessibility settings to deuteranopia mode
    let mut settings = AccessibilitySettings::default();
    settings.color_blind_mode = ColorBlindMode::Deuteranopia;
    app.world.insert_resource(settings);
    
    // Set up cards of different colors
    let red_card = app.world.spawn((
        Card::new("Red Card"),
        CardColor::Red,
        Transform::from_xyz(100.0, 100.0, 0.0),
        GlobalTransform::default(),
    )).id();
    
    let green_card = app.world.spawn((
        Card::new("Green Card"),
        CardColor::Green,
        Transform::from_xyz(300.0, 100.0, 0.0),
        GlobalTransform::default(),
    )).id();
    
    // Run systems to update card appearance
    app.update();
    
    // Get card visual components
    let red_card_appearance = app.world.get::&lt;CardAppearance&gt;(red_card).unwrap();
    let green_card_appearance = app.world.get::&lt;CardAppearance&gt;(green_card).unwrap();
    
    // In deuteranopia mode, these colors should have distinct patterns or indicators
    // rather than relying solely on red/green color difference
    assert_ne!(
        red_card_appearance.pattern_type,
        green_card_appearance.pattern_type,
        "Cards should have distinct patterns in color blind mode"
    );
}
<span class="boring">}</span></code></pre></pre>
<h3 id="keyboard-navigation-tests"><a class="header" href="#keyboard-navigation-tests">Keyboard Navigation Tests</a></h3>
<p>Test keyboard navigation through UI elements:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_keyboard_navigation() {
    // Create test app
    let mut app = App::new();
    app.add_plugins(GameUiTestPlugins)
       .add_systems(Update, ui_systems::handle_keyboard_input);
    
    // Set up test game
    setup_test_game(&amp;mut app, 2);
    
    // Initialize UI focus state
    app.world.insert_resource(UiFocus {
        current_focus: None,
        navigation_mode: true,
    });
    
    // Simulate keyboard input to start navigation
    app.world.send_event(KeyboardInput {
        key: KeyCode::Tab,
        state: ButtonState::Pressed,
    });
    app.update();
    
    // Verify navigation mode is active and something is focused
    let ui_focus = app.world.resource::&lt;UiFocus&gt;();
    assert!(ui_focus.navigation_mode, "Keyboard navigation mode should be active");
    assert!(ui_focus.current_focus.is_some(), "An element should be focused");
    
    // Test navigation between elements
    let first_focus = ui_focus.current_focus;
    
    // Simulate arrow key press
    app.world.send_event(KeyboardInput {
        key: KeyCode::ArrowRight,
        state: ButtonState::Pressed,
    });
    app.update();
    
    // Verify focus changed
    let ui_focus = app.world.resource::&lt;UiFocus&gt;();
    assert_ne!(ui_focus.current_focus, first_focus, "Focus should have moved to a new element");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="automation-framework"><a class="header" href="#automation-framework">Automation Framework</a></h2>
<p>The testing framework uses several helper functions and utilities:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Set up a test playmat with all zones for a player
fn setup_test_playmat(app: &amp;mut App, player_id: PlayerId) -&gt; Entity {
    // Create player entity
    let player_entity = app.world.spawn((
        Player { id: player_id, name: format!("Test Player {}", player_id.0) },
    )).id();
    
    // Spawn playmat
    let playmat_entity = app.world.spawn((
        PlayerPlaymat { player_id },
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(100.0),
            flex_direction: FlexDirection::Column,
            ..default()
        },
    )).id();
    
    // Spawn hand zone
    let hand_entity = app.world.spawn((
        HandZone { player_id, expanded: false },
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(20.0),
            ..default()
        },
        Parent(playmat_entity),
    )).id();
    app.world.entity_mut(playmat_entity).add_child(hand_entity);
    
    // Spawn battlefield zone
    let battlefield_entity = app.world.spawn((
        BattlefieldZone {
            player_id,
            organization: BattlefieldOrganization::ByType,
        },
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(60.0),
            ..default()
        },
        Parent(playmat_entity),
    )).id();
    app.world.entity_mut(playmat_entity).add_child(battlefield_entity);
    
    // Add other zones (library, graveyard, etc.)
    // ...
    
    playmat_entity
}

/// Set up a test game with the specified number of players
fn setup_test_game(app: &amp;mut App, player_count: usize) {
    // Create game state
    let mut game_state = GameState::default();
    game_state.player_count = player_count;
    app.world.insert_resource(game_state);
    
    // Create table
    let table_entity = app.world.spawn((
        VirtualTable,
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(100.0),
            ..default()
        },
    )).id();
    
    // Add playmats for each player
    for i in 0..player_count {
        let player_id = PlayerId(i as u32 + 1);
        let playmat_entity = setup_test_playmat(app, player_id);
        app.world.entity_mut(table_entity).add_child(playmat_entity);
    }
    
    // Add shared zones
    setup_shared_zones(app, table_entity);
}

/// Helper function to take screenshot in tests
fn take_screenshot(app: &amp;App) -&gt; Image {
    // Implementation would depend on rendering backend
    // This is a simplified example
    let mut image = Image::default();
    
    // Get main camera
    let camera_entity = app.world.query_filtered::&lt;Entity, With&lt;Camera&gt;&gt;().single(&amp;app.world);
    
    // Render to texture
    // (Implementation details would depend on Bevy's rendering API)
    
    image
}
<span class="boring">}</span></code></pre></pre>
<h2 id="test-case-organization"><a class="header" href="#test-case-organization">Test Case Organization</a></h2>
<p>Test cases are organized into test suites that focus on specific aspects of the UI:</p>
<ol>
<li><strong>Layout Tests</strong>: Verify correct positioning and sizing of UI elements</li>
<li><strong>Interaction Tests</strong>: Verify user interactions work correctly</li>
<li><strong>Visual Tests</strong>: Verify visual appearance matches expectations</li>
<li><strong>Performance Tests</strong>: Verify UI performance under different conditions</li>
<li><strong>Accessibility Tests</strong>: Verify accessibility features work correctly</li>
<li><strong>Integration Tests</strong>: Verify different UI components work together</li>
</ol>
<p>Each test suite is implemented as a separate module, with common helpers in a shared module:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod layout_tests {
    use super::*;
    
    #[test]
    fn test_two_player_table_layout() { /* ... */ }
    
    #[test]
    fn test_four_player_table_layout() { /* ... */ }
    
    // More layout tests...
}

mod interaction_tests {
    use super::*;
    
    #[test]
    fn test_card_selection() { /* ... */ }
    
    #[test]
    fn test_drag_and_drop() { /* ... */ }
    
    // More interaction tests...
}

// More test modules...
<span class="boring">}</span></code></pre></pre>
<p>When running tests, use tags to run specific categories:</p>
<pre><code class="language-bash">cargo test ui::layout  # Run layout tests
cargo test ui::visual  # Run visual tests
cargo test ui::all     # Run all UI tests
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-documentation"><a class="header" href="#networking-documentation">Networking Documentation</a></h1>
<p>This section outlines the implementation of multiplayer functionality for the Rummage MTG Commander game engine using bevy_replicon.</p>
<h2 id="table-of-contents-8"><a class="header" href="#table-of-contents-8">Table of Contents</a></h2>
<ol>
<li><a href="networking/index.html#overview">Overview</a></li>
<li><a href="networking/index.html#key-components">Key Components</a></li>
<li><a href="networking/index.html#implementation-status">Implementation Status</a></li>
<li><a href="networking/index.html#recent-updates">Recent Updates</a></li>
<li><a href="networking/index.html#getting-started">Getting Started</a></li>
<li><a href="networking/index.html#future-enhancements">Future Enhancements</a></li>
</ol>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>The networking system enables multiplayer gameplay with features like state synchronization, lobby management, and rollback mechanisms for handling network disruptions. The implementation is built on bevy_replicon, providing a robust foundation for networked gameplay.</p>
<p>For a comprehensive overview, see the <a href="networking/core/architecture_overview.html">Core Architecture Overview</a>.</p>
<h2 id="key-components-2"><a class="header" href="#key-components-2">Key Components</a></h2>
<p>The networking system consists of the following major components:</p>
<h3 id="core-networking"><a class="header" href="#core-networking">Core Networking</a></h3>
<ul>
<li><a href="networking/core/architecture_overview.html">Architecture Overview</a> - Introduction to networking architecture and concepts</li>
<li><a href="networking/core/implementation_details.html">Implementation Details</a> - Detailed implementation guidelines and code structure</li>
<li><a href="networking/core/protocol_specification.html">Protocol Specification</a> - Networking protocol, message formats, and synchronization</li>
<li><a href="networking/core/multiplayer_overview.html">Multiplayer Overview</a> - High-level overview of multiplayer functionality</li>
<li><a href="networking/core/implementation_details.html#random-number-generator-synchronization">RNG Synchronization</a> - Managing random number generation across network boundaries</li>
</ul>
<h3 id="lobby-system"><a class="header" href="#lobby-system">Lobby System</a></h3>
<ul>
<li><a href="networking/lobby/index.html">Lobby Index</a> - Overview of the lobby system</li>
<li><a href="networking/lobby/ui/">UI Components</a> - Documentation for user interface components</li>
<li><a href="networking/lobby/backend/">Backend</a> - Server-side implementation details</li>
<li><a href="networking/lobby/chat/">Chat System</a> - Chat functionality documentation</li>
<li><a href="networking/lobby/deck/">Deck Viewer</a> - Deck viewing and management</li>
</ul>
<h3 id="gameplay-networking"><a class="header" href="#gameplay-networking">Gameplay Networking</a></h3>
<ul>
<li><a href="networking/gameplay/departure/handling.html">Departure Handling</a> - Handling player disconnections and departures</li>
<li><a href="networking/gameplay/state/">State Management</a> - Game state synchronization
<ul>
<li><a href="networking/gameplay/state/rollback.html">Rollback System</a> - State recovery after network disruptions</li>
<li><a href="networking/gameplay/state/replicon_rollback.html">Replicon Rollback Integration</a> - Integrating bevy_replicon with RNG state for rollbacks</li>
</ul>
</li>
<li><a href="networking/gameplay/synchronization/">Synchronization</a> - Methods for keeping game state in sync</li>
</ul>
<h3 id="testing-6"><a class="header" href="#testing-6">Testing</a></h3>
<ul>
<li><a href="networking/testing/overview.html">Testing Overview</a> - General testing approach</li>
<li><a href="networking/testing/advanced_techniques.html">Advanced Techniques</a> - Advanced testing techniques</li>
<li><a href="networking/testing/rng_synchronization_tests.html">RNG Synchronization Tests</a> - Testing RNG determinism in multiplayer</li>
<li><a href="networking/testing/replicon_rng_tests.html">Replicon RNG Tests</a> - Testing bevy_replicon integration with RNG state</li>
<li><a href="networking/testing/integration/">Integration Testing</a> - Integration testing methodologies</li>
<li><a href="networking/testing/security/">Security Testing</a> - Security-focused testing</li>
</ul>
<h3 id="security"><a class="header" href="#security">Security</a></h3>
<ul>
<li><a href="networking/security/authentication.html">Authentication</a> - User authentication and authorization</li>
<li><a href="networking/security/anti_cheat.html">Anti-Cheat</a> - Preventing and detecting cheating</li>
<li><a href="networking/security/hidden_information.html">Hidden Information</a> - Managing hidden game information</li>
</ul>
<h2 id="implementation-status-2"><a class="header" href="#implementation-status-2">Implementation Status</a></h2>
<p>This documentation represents the design and implementation of the networking system. Components are marked as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Status</th><th>Description</th></tr></thead><tbody>
<tr><td>Core Network Architecture</td><td>‚úÖ</td><td>Basic network architecture using bevy_replicon</td></tr>
<tr><td>Client-Server Communication</td><td>‚úÖ</td><td>Basic client-server messaging</td></tr>
<tr><td>Lobby System</td><td>üîÑ</td><td>System for creating and joining game lobbies</td></tr>
<tr><td>Game State Synchronization</td><td>üîÑ</td><td>Synchronizing game state across the network</td></tr>
<tr><td>RNG Synchronization</td><td>‚úÖ</td><td>Maintaining consistent random number generation</td></tr>
<tr><td>Rollback System</td><td>‚úÖ</td><td>Recovery from network disruptions</td></tr>
<tr><td>Replicon Integration</td><td>‚úÖ</td><td>Integration with bevy_replicon for entity replication</td></tr>
<tr><td>Auth System</td><td>‚ö†Ô∏è</td><td>Player authentication and authorization</td></tr>
<tr><td>Anti-Cheat</td><td>‚ö†Ô∏è</td><td>Measures to prevent cheating</td></tr>
<tr><td>Hidden Information</td><td>üîÑ</td><td>Managing information that should be hidden from certain players</td></tr>
<tr><td>Chat System</td><td>‚ö†Ô∏è</td><td>In-game communication</td></tr>
<tr><td>Spectator Mode</td><td>‚ö†Ô∏è</td><td>Support for non-player observers</td></tr>
</tbody></table>
</div>
<p>Legend:</p>
<ul>
<li>‚úÖ Implemented and tested</li>
<li>üîÑ In progress</li>
<li>‚ö†Ô∏è Planned but not yet implemented</li>
</ul>
<h2 id="recent-updates"><a class="header" href="#recent-updates">Recent Updates</a></h2>
<p>Recent updates to the networking documentation include:</p>
<ul>
<li><strong>Replicon Integration</strong>: Added detailed documentation for integrating bevy_replicon with our RNG state management system</li>
<li><strong>Rollback Mechanism</strong>: Enhanced documentation of rollback mechanisms for handling network disruptions</li>
<li><strong>Test Framework</strong>: Expanded testing documentation with new test cases for RNG synchronization</li>
<li><strong>Performance Considerations</strong>: Added guidance on optimizing network performance</li>
</ul>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>To begin working on the networking implementation:</p>
<ol>
<li>Review the <a href="networking/core/architecture_overview.html">Core Architecture Overview</a></li>
<li>Understand the <a href="networking/core/implementation_details.html">Implementation Details</a></li>
<li>Set up a local development environment with bevy_replicon</li>
<li>Start with the basic client-server connectivity</li>
<li>Incrementally add features following the implementation plan</li>
</ol>
<h2 id="future-enhancements-1"><a class="header" href="#future-enhancements-1">Future Enhancements</a></h2>
<p>In future versions, we plan to enhance the networking implementation with:</p>
<ul>
<li><strong>Spectator Mode</strong>: Allow non-players to watch games in progress</li>
<li><strong>Replay System</strong>: Record and replay games for analysis or sharing</li>
<li><strong>Tournament Support</strong>: Special features for organizing and running tournaments</li>
<li><strong>Cross-Platform Play</strong>: Ensure compatibility across different platforms</li>
<li><strong>Advanced Anti-Cheat</strong>: More sophisticated measures to prevent cheating</li>
<li><strong>Voice Chat Integration</strong>: In-game communication between players</li>
</ul>
<hr />
<p>This documentation will evolve as the networking implementation progresses. Check back regularly for updates and additional details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-implementation-with-bevy_replicon"><a class="header" href="#networking-implementation-with-bevy_replicon">Networking Implementation with bevy_replicon</a></h1>
<p>This document outlines the architecture and implementation details for adding multiplayer networking support to our MTG Commander game engine using <code>bevy_replicon</code>.</p>
<h2 id="table-of-contents-9"><a class="header" href="#table-of-contents-9">Table of Contents</a></h2>
<ol>
<li><a href="networking/core/architecture_overview.html#overview">Overview</a></li>
<li><a href="networking/core/architecture_overview.html#setup-and-dependencies">Setup and Dependencies</a></li>
<li><a href="networking/core/architecture_overview.html#architecture">Architecture</a></li>
<li><a href="networking/core/architecture_overview.html#server-implementation">Server Implementation</a></li>
<li><a href="networking/core/architecture_overview.html#client-implementation">Client Implementation</a></li>
<li><a href="networking/core/architecture_overview.html#replication-strategy">Replication Strategy</a></li>
<li><a href="networking/core/architecture_overview.html#game-state-synchronization">Game State Synchronization</a></li>
<li><a href="networking/core/architecture_overview.html#networking-events">Networking Events</a></li>
<li><a href="networking/core/architecture_overview.html#security-considerations">Security Considerations</a></li>
<li><a href="networking/core/architecture_overview.html#testing-and-debugging">Testing and Debugging</a></li>
</ol>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p><code>bevy_replicon</code> is a high-level networking library built on top of <code>bevy_renet</code> that provides a client-server replication system for Bevy. It handles entity replication, RPC (Remote Procedure Calls), and event synchronization between the server and connected clients.</p>
<p>Our implementation will focus on creating a robust, secure, and efficient networking layer that supports the complex state management required for MTG Commander games while maintaining the game rules integrity.</p>
<h2 id="setup-and-dependencies"><a class="header" href="#setup-and-dependencies">Setup and Dependencies</a></h2>
<p>Add the following dependencies to your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
# Existing dependencies...
bevy_replicon = "0.15.0"
bevy_quinnet = { version = "0.6.0", optional = true }
serde = { version = "1.0", features = ["derive"] }
bincode = "1.3"
</code></pre>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>Our networking architecture follows a client-server model:</p>
<ol>
<li><strong>Server</strong>: Maintains authoritative game state, handles game logic, and broadcasts state changes to clients</li>
<li><strong>Clients</strong>: Connect to the server, send player actions, and render game state received from the server</li>
</ol>
<h3 id="key-components-3"><a class="header" href="#key-components-3">Key Components:</a></h3>
<ul>
<li><strong>NetworkingPlugin</strong>: Initializes all networking systems and components</li>
<li><strong>ServerPlugin</strong>: Handles server-specific logic when running as a server</li>
<li><strong>ClientPlugin</strong>: Handles client-specific logic when running as a client</li>
<li><strong>ReplicationSet</strong>: Defines which components should be replicated from server to clients</li>
<li><strong>NetworkedActions</strong>: Server-validated actions that clients can request</li>
</ul>
<h2 id="server-implementation"><a class="header" href="#server-implementation">Server Implementation</a></h2>
<p>The server is the authoritative source of truth for game state and handles:</p>
<ol>
<li>Game session creation and management</li>
<li>Player connections and authentication</li>
<li>Processing game actions and maintaining game rules</li>
<li>Broadcasting state updates to connected clients</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/networking/server.rs
use bevy::prelude::*;
use bevy_replicon::prelude::*;
use crate::game_engine::GameAction;

pub struct ServerPlugin;

impl Plugin for ServerPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app
            .add_plugins(bevy_replicon::prelude::ServerPlugin::default())
            .add_systems(Startup, setup_server)
            .add_systems(Update, (
                handle_player_connections,
                process_action_requests,
                validate_game_state,
                broadcast_game_events,
            ));
    }
}

fn setup_server(mut commands: Commands) {
    // Initialize server resources
    commands.insert_resource(GameServer::new());
    
    // Add server-specific systems and resources
    // ...
}

fn handle_player_connections(
    mut commands: Commands,
    mut server: ResMut&lt;Server&gt;,
    mut connection_events: EventReader&lt;ConnectionEvent&gt;,
    mut clients: ResMut&lt;Clients&gt;,
) {
    // Handle new player connections and disconnections
    // ...
}

fn process_action_requests(
    mut commands: Commands,
    mut server: ResMut&lt;Server&gt;,
    mut action_requests: EventReader&lt;ClientActionRequest&gt;,
    game_state: Res&lt;GameState&gt;,
) {
    // Process and validate client action requests
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="client-implementation"><a class="header" href="#client-implementation">Client Implementation</a></h2>
<p>The client is responsible for:</p>
<ol>
<li>Connecting to the server</li>
<li>Sending player inputs and action requests</li>
<li>Rendering the replicated game state</li>
<li>Providing feedback for connection status</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/networking/client.rs
use bevy::prelude::*;
use bevy_replicon::prelude::*;
use crate::game_engine::GameAction;

pub struct ClientPlugin;

impl Plugin for ClientPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app
            .add_plugins(bevy_replicon::prelude::ClientPlugin::default())
            .add_systems(Startup, setup_client)
            .add_systems(Update, (
                handle_connection_status,
                send_player_actions,
                apply_server_updates,
            ));
    }
}

fn setup_client(mut commands: Commands) {
    // Initialize client resources
    commands.insert_resource(GameClient::new());
    
    // Add client-specific systems and resources
    // ...
}

fn handle_connection_status(
    mut connection_events: EventReader&lt;ConnectionEvent&gt;,
    mut client_state: ResMut&lt;ClientState&gt;,
) {
    // Update UI based on connection status
    // ...
}

fn send_player_actions(
    mut client: ResMut&lt;Client&gt;,
    mut action_queue: ResMut&lt;ActionQueue&gt;,
    input: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    // Send player actions to the server
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="replication-strategy"><a class="header" href="#replication-strategy">Replication Strategy</a></h2>
<p>We need to carefully consider which components should be replicated and how to maintain game state integrity.</p>
<h3 id="server-to-client-replication"><a class="header" href="#server-to-client-replication">Server-to-Client Replication:</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/networking/replication.rs
use bevy::prelude::*;
use bevy_replicon::prelude::*;
use crate::card::Card;
use crate::player::Player;
use crate::game_engine::{GameState, Phase, PrioritySystem};

pub fn register_replication_components(app: &amp;mut App) {
    app
        // Register components that should be replicated
        .replicate::&lt;Card&gt;()
        .replicate::&lt;Player&gt;()
        .replicate::&lt;GameState&gt;()
        .replicate::&lt;Phase&gt;()
        .replicate::&lt;PrioritySystem&gt;()
        // Register custom events for replication
        .replicate_event::&lt;GameAction&gt;();
}

#[derive(Component, Serialize, Deserialize, Default)]
pub struct NetworkedEntity;

#[derive(Component, Serialize, Deserialize)]
pub struct OwnerOnly {
    pub player_id: u64,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="game-state-synchronization"><a class="header" href="#game-state-synchronization">Game State Synchronization</a></h2>
<p>MTG requires careful synchronization of complex game states:</p>
<h3 id="card-visibility-and-privacy"><a class="header" href="#card-visibility-and-privacy">Card Visibility and Privacy:</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of handling card visibility for networked games
// src/networking/visibility.rs
use bevy::prelude::*;
use bevy_replicon::prelude::*;
use crate::card::Card;
use crate::game_engine::zones::{Zone, ZoneType};

// Components for visibility control
#[derive(Component)]
pub struct VisibleTo {
    pub player_ids: Vec&lt;u64&gt;,
}

// System to update card visibility based on game rules
fn update_card_visibility(
    mut commands: Commands,
    mut cards: Query&lt;(Entity, &amp;Card, &amp;Zone, Option&lt;&amp;VisibleTo&gt;)&gt;,
    players: Query&lt;(Entity, &amp;Player)&gt;,
) {
    for (entity, card, zone, visible_to) in &amp;mut cards {
        match zone.zone_type {
            ZoneType::Hand =&gt; {
                // Only visible to owner
                let owner_id = card.owner.id();
                commands.entity(entity).insert(VisibleTo {
                    player_ids: vec![owner_id],
                });
            },
            ZoneType::Battlefield =&gt; {
                // Visible to all players
                commands.entity(entity).remove::&lt;VisibleTo&gt;();
            },
            // Handle other zone types...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="networking-events"><a class="header" href="#networking-events">Networking Events</a></h2>
<p>Define custom events for networking-related actions:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/networking/events.rs
use bevy::prelude::*;
use serde::{Serialize, Deserialize};

#[derive(Event, Serialize, Deserialize, Clone, Debug)]
pub struct ClientActionRequest {
    pub player_id: u64,
    pub action_type: NetworkedActionType,
    pub targets: Vec&lt;Entity&gt;,
    // Additional parameters specific to the action type
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum NetworkedActionType {
    PlayLand,
    CastSpell,
    ActivateAbility { ability_index: usize },
    PassPriority,
    MulliganDecision { keep: bool },
    CommanderZoneChoice { to_command_zone: bool },
    DeclareAttackers { attackers: Vec&lt;Entity&gt; },
    DeclareBlockers { blockers: Vec&lt;(Entity, Entity)&gt; },
    // Additional action types as needed
}

// Implement server-to-client events for game updates
#[derive(Event, Serialize, Deserialize, Clone, Debug)]
pub struct GameStateUpdate {
    pub active_player: Entity,
    pub phase: Phase,
    pub priority_player: Option&lt;Entity&gt;,
    // Additional state information
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<p>Security is crucial for card games to prevent cheating:</p>
<ol>
<li>
<p><strong>Server Authority</strong>: The server is the sole authority for game state. All client actions must be validated by the server.</p>
</li>
<li>
<p><strong>Action Validation</strong>: Each client action must be validated against the current game state and rules.</p>
</li>
<li>
<p><strong>Anti-Cheat Measures</strong>:</p>
<ul>
<li>Hidden information (hand cards) should only be sent to the appropriate player</li>
<li>Random events (shuffling, coin flips) should be performed on the server</li>
<li>Rate-limiting client requests to prevent DoS attacks</li>
</ul>
</li>
<li>
<p><strong>Reconnection Handling</strong>: Players should be able to reconnect to games in progress.</p>
</li>
</ol>
<h2 id="testing-and-debugging"><a class="header" href="#testing-and-debugging">Testing and Debugging</a></h2>
<p>For effective testing and debugging of the networking implementation:</p>
<ol>
<li><strong>Local Testing</strong>: Simulate a networked environment on a single machine</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/networking/testing.rs
pub fn setup_local_test_environment(app: &amp;mut App) {
    app
        .add_plugins(ServerPlugin)
        .add_plugins(ClientPlugin)
        .add_systems(Startup, spawn_test_clients);
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>
<p><strong>Integration Tests</strong>: Dedicated tests for network functionality</p>
</li>
<li>
<p><strong>Network Condition Simulation</strong>: Test under various network conditions (latency, packet loss)</p>
</li>
<li>
<p><strong>Logging and Monitoring</strong>: Comprehensive logging of network events</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn log_network_events(
    connection_events: EventReader&lt;ConnectionEvent&gt;,
    client_events: EventReader&lt;ClientActionRequest&gt;,
    server_events: EventReader&lt;GameStateUpdate&gt;,
) {
    for event in connection_events.read() {
        info!("Connection event: {:?}", event);
    }
    
    // Log other events...
}
<span class="boring">}</span></code></pre></pre>
<hr />
<p>This document provides a high-level overview of implementing networking with bevy_replicon for the MTG Commander game engine. Implementation details will need to be adjusted based on specific game requirements and the evolving architecture of the game.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiplayer-lobby-system-documentation"><a class="header" href="#multiplayer-lobby-system-documentation">Multiplayer Lobby System Documentation</a></h1>
<p>This document serves as an index for all documentation related to Rummage's multiplayer lobby system for Commander format games. These documents cover the user interface, networking architecture, and implementation details for creating a robust and enjoyable multiplayer experience.</p>
<h2 id="overview-and-architecture"><a class="header" href="#overview-and-architecture">Overview and Architecture</a></h2>
<ul>
<li><a href="networking/lobby/lobby_ui_overview.html">Lobby UI System Overview</a> - High-level overview of the lobby UI architecture and flow</li>
<li><a href="networking/lobby/lobby_networking.html">Lobby Networking</a> - Networking architecture for the lobby system</li>
<li><a href="networking/lobby/lobby_backend.html">Lobby Backend</a> - Server-side implementation details</li>
</ul>
<h2 id="user-interface-components"><a class="header" href="#user-interface-components">User Interface Components</a></h2>
<ul>
<li><a href="networking/lobby/lobby_browser_ui.html">Lobby Browser UI</a> - UI for browsing available game lobbies</li>
<li><a href="networking/lobby/lobby_detail_ui.html">Lobby Detail UI</a> - UI for the specific lobby view, player management, and ready-up mechanics</li>
<li><a href="networking/lobby/lobby_chat_ui.html">Lobby Chat UI</a> - Chat system implementation for lobby communication</li>
<li><a href="networking/lobby/lobby_deck_viewer.html">Lobby Deck Viewer</a> - Deck and commander viewing UI</li>
</ul>
<h2 id="gameplay-and-departure-handling"><a class="header" href="#gameplay-and-departure-handling">Gameplay and Departure Handling</a></h2>
<ul>
<li><a href="networking/lobby/game_departure_handling.html">Game Departure Handling</a> - How the system handles players leaving games</li>
</ul>
<h2 id="implementation-guides"><a class="header" href="#implementation-guides">Implementation Guides</a></h2>
<ul>
<li><a href="networking/lobby/../development/lobby_implementation.html">Lobby Implementation Guide</a> - Step-by-step guide for implementing lobby features</li>
<li><a href="networking/lobby/../testing/lobby_testing.html">Lobby Testing Guide</a> - Testing strategies for the lobby system</li>
</ul>
<h2 id="feature-highlights"><a class="header" href="#feature-highlights">Feature Highlights</a></h2>
<h3 id="server-list-and-direct-connect"><a class="header" href="#server-list-and-direct-connect">Server List and Direct Connect</a></h3>
<p>The lobby system supports two connection methods:</p>
<ol>
<li><strong>Server List</strong>: Browse a list of available lobby servers</li>
<li><strong>Direct Connect</strong>: Connect directly to a specific host's IP</li>
</ol>
<h3 id="lobby-browsing"><a class="header" href="#lobby-browsing">Lobby Browsing</a></h3>
<p>The browser screen provides a comprehensive view of available lobbies with:</p>
<ul>
<li>Lobby name and host information</li>
<li>Player count and maximum players</li>
<li>Game format details</li>
<li>Password protection indicator</li>
<li>Filtering and sorting options</li>
</ul>
<h3 id="in-lobby-features"><a class="header" href="#in-lobby-features">In-Lobby Features</a></h3>
<p>Once in a lobby, players can:</p>
<ul>
<li>Chat with other players</li>
<li>View player information</li>
<li>Select a deck and indicate readiness</li>
<li>View other players' commander cards and deck information</li>
<li>Manage privacy settings for their decks</li>
</ul>
<h3 id="host-controls"><a class="header" href="#host-controls">Host Controls</a></h3>
<p>Lobby hosts have additional capabilities:</p>
<ul>
<li>Kick players</li>
<li>Set lobby rules and restrictions</li>
<li>Configure game settings</li>
<li>Launch the game when all players are ready</li>
</ul>
<h3 id="privacy-and-deck-sharing"><a class="header" href="#privacy-and-deck-sharing">Privacy and Deck Sharing</a></h3>
<p>The system implements flexible privacy settings:</p>
<ul>
<li>Share just commander information</li>
<li>Share basic deck statistics</li>
<li>Share full decklist</li>
<li>Customizable sharing options</li>
</ul>
<h3 id="robust-departure-handling"><a class="header" href="#robust-departure-handling">Robust Departure Handling</a></h3>
<p>The system gracefully handles various departure scenarios:</p>
<ul>
<li>Voluntary quits</li>
<li>Being kicked by host</li>
<li>Temporary disconnections with reconnection window</li>
<li>Preservation of game state for departed players</li>
</ul>
<h2 id="implementation-details-5"><a class="header" href="#implementation-details-5">Implementation Details</a></h2>
<p>The lobby system is built using:</p>
<ul>
<li><strong>Bevy ECS</strong>: Component-based architecture for UI and game state</li>
<li><strong>Bevy Replicon</strong>: Networking and state replication</li>
<li><strong>WebRTC</strong>: For efficient and reliable UDP-based communication</li>
<li><strong>Delta Compression</strong>: For efficient state updates</li>
</ul>
<h2 id="getting-started-2"><a class="header" href="#getting-started-2">Getting Started</a></h2>
<p>To get started with implementing or extending the lobby system, we recommend:</p>
<ol>
<li>Review the <a href="networking/lobby/lobby_ui_overview.html">Lobby UI System Overview</a> for a high-level understanding</li>
<li>Examine the <a href="networking/lobby/lobby_networking.html">Lobby Networking</a> document to understand the communication architecture</li>
<li>Follow the step-by-step <a href="networking/lobby/../development/lobby_implementation.html">Lobby Implementation Guide</a></li>
</ol>
<h2 id="future-enhancements-2"><a class="header" href="#future-enhancements-2">Future Enhancements</a></h2>
<p>Planned enhancements for the lobby system include:</p>
<ul>
<li>Voice chat integration</li>
<li>Advanced deck analysis tools</li>
<li>Tournament mode</li>
<li>Spectator support</li>
<li>Enhanced moderation tools</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gameplay-networking-documentation"><a class="header" href="#gameplay-networking-documentation">Gameplay Networking Documentation</a></h1>
<p>This section covers the networking aspects specific to gameplay in the MTG Commander game engine. While the lobby system handles pre-game setup, the gameplay networking components manage the actual game session, including state synchronization, player actions, and handling departures.</p>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>The gameplay networking implementation focuses on several key areas:</p>
<ol>
<li><strong>State Management</strong>: Maintaining and synchronizing the game state across all clients</li>
<li><strong>Action Processing</strong>: Handling player actions and their effects on the game state</li>
<li><strong>Synchronization</strong>: Ensuring all clients have a consistent view of the game</li>
<li><strong>Departure Handling</strong>: Managing player disconnections and reconnections</li>
</ol>
<h2 id="gameplay-components"><a class="header" href="#gameplay-components">Gameplay Components</a></h2>
<h3 id="state-management"><a class="header" href="#state-management">State Management</a></h3>
<p>The <a href="networking/gameplay/state/index.html">State Management</a> system handles the representation and replication of game state:</p>
<ul>
<li>Core game state structure and components</li>
<li>State replication with bevy_replicon</li>
<li>Hidden information management</li>
<li>State consistency and verification</li>
<li><a href="networking/gameplay/state/rollback.html">Rollback and Recovery</a> for handling network disruptions</li>
</ul>
<h3 id="synchronization"><a class="header" href="#synchronization">Synchronization</a></h3>
<p>The <a href="networking/gameplay/synchronization/index.html">Synchronization</a> system ensures all clients maintain a consistent view of the game:</p>
<ul>
<li>Server-authoritative model</li>
<li>Command-based synchronization</li>
<li>Incremental state updates</li>
<li>Tick-based processing</li>
<li>Handling network issues</li>
</ul>
<h3 id="departure-handling"><a class="header" href="#departure-handling">Departure Handling</a></h3>
<p>The <a href="networking/gameplay/departure/handling.html">Departure Handling</a> system manages player disconnections and reconnections:</p>
<ul>
<li>Detecting disconnections</li>
<li>Preserving game state for disconnected players</li>
<li>Handling reconnections</li>
<li>Game continuation policies</li>
<li>Timeout and abandonment handling</li>
</ul>
<h2 id="implementation-principles-1"><a class="header" href="#implementation-principles-1">Implementation Principles</a></h2>
<p>Our gameplay networking implementation follows these core principles:</p>
<ol>
<li><strong>Server Authority</strong>: The server is the single source of truth for game state</li>
<li><strong>Minimal Network Usage</strong>: Only necessary information is transmitted</li>
<li><strong>Resilience</strong>: The system can handle network disruptions gracefully through deterministic rollbacks</li>
<li><strong>Security</strong>: Hidden information remains protected</li>
<li><strong>Fairness</strong>: All players have equal opportunity regardless of network conditions</li>
<li><strong>Determinism</strong>: Game actions produce identical results when replayed with the same RNG state</li>
</ol>
<h2 id="integration-with-other-systems"><a class="header" href="#integration-with-other-systems">Integration with Other Systems</a></h2>
<p>The gameplay networking components integrate with several other systems:</p>
<ul>
<li><strong>Lobby System</strong>: For transitioning from lobby to game</li>
<li><strong>Security</strong>: For protecting hidden information and preventing cheating</li>
<li><strong>Testing</strong>: For validating network behavior and performance</li>
</ul>
<h2 id="future-enhancements-3"><a class="header" href="#future-enhancements-3">Future Enhancements</a></h2>
<p>Planned gameplay networking enhancements include:</p>
<ul>
<li><strong>Spectator Mode</strong>: Allow non-players to watch games in progress</li>
<li><strong>Replay System</strong>: Record and replay games for analysis</li>
<li><strong>Enhanced Reconnection</strong>: More sophisticated state recovery for long disconnections</li>
<li><strong>Optimized Synchronization</strong>: Improved performance for complex game states</li>
<li><strong>Cross-Platform Play</strong>: Ensure consistent experience across different platforms</li>
</ul>
<hr />
<p>This documentation will evolve as the gameplay networking implementation progresses.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-state-management-in-mtg-commander"><a class="header" href="#game-state-management-in-mtg-commander">Game State Management in MTG Commander</a></h1>
<p>This document outlines the approach to managing game state in the MTG Commander game engine's multiplayer implementation.</p>
<h2 id="table-of-contents-10"><a class="header" href="#table-of-contents-10">Table of Contents</a></h2>
<ol>
<li><a href="networking/gameplay/state/index.html#overview">Overview</a></li>
<li><a href="networking/gameplay/state/index.html#game-state-components">Game State Components</a></li>
<li><a href="networking/gameplay/state/index.html#implementation-approach">Implementation Approach</a></li>
<li><a href="networking/gameplay/state/index.html#state-snapshots">State Snapshots</a></li>
<li><a href="networking/gameplay/state/index.html#state-synchronization">State Synchronization</a></li>
<li><a href="networking/gameplay/state/index.html#deterministic-state-updates">Deterministic State Updates</a></li>
<li><a href="networking/gameplay/state/index.html#hidden-information">Hidden Information</a></li>
<li><a href="networking/gameplay/state/index.html#rollbacks-and-recovery">Rollbacks and Recovery</a></li>
</ol>
<h2 id="overview-9"><a class="header" href="#overview-9">Overview</a></h2>
<p>Proper game state management is critical for a multiplayer card game like Magic: The Gathering. The game state includes all information about the current game, including cards in various zones, player life totals, turn structure, and active effects. In a networked environment, this state must be synchronized across all clients while maintaining security and performance.</p>
<h2 id="game-state-components"><a class="header" href="#game-state-components">Game State Components</a></h2>
<p>The game state in MTG Commander consists of several key components:</p>
<ol>
<li><strong>Zones</strong>: Battlefield, hands, libraries, graveyards, exile, stack, and command zone</li>
<li><strong>Player Information</strong>: Life totals, mana pools, commander damage, etc.</li>
<li><strong>Turn Structure</strong>: Current phase, active player, priority player</li>
<li><strong>Effects</strong>: Ongoing effects, delayed triggers, replacement effects</li>
<li><strong>Game Metadata</strong>: Game ID, start time, game mode, etc.</li>
</ol>
<h2 id="implementation-approach"><a class="header" href="#implementation-approach">Implementation Approach</a></h2>
<h3 id="core-game-state-structure"><a class="header" href="#core-game-state-structure">Core Game State Structure</a></h3>
<p>The game state is implemented as a collection of ECS components and resources:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Core game state resource
#[derive(Resource)]
pub struct GameState {
    pub game_id: Uuid,
    pub start_time: DateTime&lt;Utc&gt;,
    pub game_mode: GameMode,
    pub turn_number: u32,
    pub current_phase: Phase,
    pub active_player_id: PlayerId,
    pub priority_player_id: Option&lt;PlayerId&gt;,
    pub stack: Vec&lt;StackItem&gt;,
}

// Player component
#[derive(Component)]
pub struct Player {
    pub id: PlayerId,
    pub client_id: ClientId,
    pub life_total: i32,
    pub mana_pool: ManaPool,
    pub commander_damage: HashMap&lt;PlayerId, i32&gt;,
}

// Zone components
#[derive(Component)]
pub struct Hand {
    pub cards: Vec&lt;CardId&gt;,
}

#[derive(Component)]
pub struct Library {
    pub cards: Vec&lt;CardId&gt;,
    pub top_revealed: bool,
}

#[derive(Component)]
pub struct Graveyard {
    pub cards: Vec&lt;CardId&gt;,
}

#[derive(Component)]
pub struct CommandZone {
    pub cards: Vec&lt;CardId&gt;,
}

// Battlefield is a shared resource
#[derive(Resource)]
pub struct Battlefield {
    pub permanents: Vec&lt;Entity&gt;,
}

// Card component
#[derive(Component)]
pub struct Card {
    pub id: CardId,
    pub name: String,
    pub card_type: CardType,
    pub owner_id: PlayerId,
    pub controller_id: PlayerId,
    // Other card properties...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="state-replication-with-bevy_replicon"><a class="header" href="#state-replication-with-bevy_replicon">State Replication with bevy_replicon</a></h3>
<p>The game state is replicated using bevy_replicon, with careful control over what information is sent to each client:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Register components for replication
fn register_replication(app: &amp;mut App) {
    app.register_component_replication::&lt;Player&gt;()
        .register_component_replication::&lt;Card&gt;()
        // Only replicate public zone information
        .register_component_replication::&lt;Graveyard&gt;()
        .register_component_replication::&lt;CommandZone&gt;()
        // Register resources
        .register_resource_replication::&lt;GameState&gt;()
        .register_resource_replication::&lt;Battlefield&gt;();
        
    // Hand and Library require special handling for hidden information
    app.register_component_replication_with::&lt;Hand&gt;(
        RuleFns {
            serialize: |hand, ctx| {
                // Only send full hand to the owner
                if ctx.client_id == ctx.client_entity_map.get_client_id(hand.owner_entity) {
                    bincode::serialize(hand).ok()
                } else {
                    // Send only card count to other players
                    bincode::serialize(&amp;HandInfo { card_count: hand.cards.len() }).ok()
                }
            },
            deserialize: |bytes, ctx| {
                // Handle deserialization based on what was sent
                // ...
            },
        }
    );
}
<span class="boring">}</span></code></pre></pre>
<h3 id="state-synchronization"><a class="header" href="#state-synchronization">State Synchronization</a></h3>
<p>The game state is synchronized across clients using a combination of techniques:</p>
<ol>
<li><strong>Initial State</strong>: Full game state is sent when a client connects</li>
<li><strong>Incremental Updates</strong>: Only changes are sent during gameplay</li>
<li><strong>Command-Based</strong>: Player actions are sent as commands, not direct state changes</li>
<li><strong>Authoritative Server</strong>: Server validates all commands before applying them</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// System to process player commands
fn process_player_commands(
    mut commands: Commands,
    mut command_events: EventReader&lt;PlayerCommand&gt;,
    game_state: Res&lt;GameState&gt;,
    players: Query&lt;(Entity, &amp;Player)&gt;,
    // Other queries...
) {
    for command in command_events.read() {
        // Validate the command
        if !validate_command(command, &amp;game_state, &amp;players) {
            continue;
        }
        
        // Apply the command to the game state
        match command {
            PlayerCommand::PlayCard { player_id, card_id, targets } =&gt; {
                // Handle playing a card
                // ...
            },
            PlayerCommand::ActivateAbility { permanent_id, ability_index, targets } =&gt; {
                // Handle activating an ability
                // ...
            },
            // Other command types...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="state-snapshots"><a class="header" href="#state-snapshots">State Snapshots</a></h2>
<p>In networked games, maintaining state consistency despite network disruptions is essential. Our MTG Commander implementation employs a comprehensive state rollback system for resilience:</p>
<ul>
<li><strong>Complete documentation:</strong> <a href="networking/gameplay/state/rollback.html">State Rollback and Recovery</a></li>
<li>Deterministic replay of game actions after network disruptions</li>
<li>State snapshots at critical game moments</li>
<li>RNG state preservation for consistent randomized outcomes</li>
<li>Client-side prediction for responsive gameplay</li>
</ul>
<p>The rollback system integrates tightly with our deterministic RNG implementation to ensure that random events like shuffling and coin flips remain consistent across network boundaries, even during recovery from disruptions.</p>
<h2 id="deterministic-state-updates"><a class="header" href="#deterministic-state-updates">Deterministic State Updates</a></h2>
<p>Maintaining state consistency is critical for a fair game experience. Several mechanisms ensure consistency:</p>
<ol>
<li><strong>Sequence Numbers</strong>: Commands are processed in order</li>
<li><strong>State Verification</strong>: Periodic full state verification</li>
<li><strong>Reconciliation</strong>: Automatic correction of client-server state differences</li>
<li><strong>Rollback</strong>: Ability to roll back to a previous state if needed</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// System to verify client state consistency
fn verify_client_state_consistency(
    mut server: ResMut&lt;RepliconServer&gt;,
    game_state: Res&lt;GameState&gt;,
    connected_clients: Res&lt;ConnectedClients&gt;,
) {
    // Periodically send state verification requests
    if game_state.turn_number % 5 == 0 &amp;&amp; game_state.current_phase == Phase::Upkeep {
        for client_id in connected_clients.clients.keys() {
            // Generate state verification data
            let verification_data = generate_state_verification_data(&amp;game_state);
            
            // Send verification request
            server.send_message(*client_id, StateVerificationRequest {
                turn: game_state.turn_number,
                verification_data,
            });
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="hidden-information"><a class="header" href="#hidden-information">Hidden Information</a></h2>
<p>In networked games, it's important to protect sensitive information from unauthorized access. MTG Commander implements several mechanisms to hide sensitive information:</p>
<ol>
<li><strong>Encryption</strong>: All network communications are encrypted</li>
<li><strong>Access Control</strong>: Only authorized clients can access certain game state information</li>
<li><strong>Data Masking</strong>: Sensitive data is masked or obfuscated</li>
</ol>
<h2 id="rollbacks-and-recovery"><a class="header" href="#rollbacks-and-recovery">Rollbacks and Recovery</a></h2>
<p>In networked games, maintaining state consistency despite network disruptions is essential. Our MTG Commander implementation employs a comprehensive state rollback system for resilience:</p>
<ul>
<li><strong>Complete documentation:</strong> <a href="networking/gameplay/state/rollback.html">State Rollback and Recovery</a></li>
<li>Deterministic replay of game actions after network disruptions</li>
<li>State snapshots at critical game moments</li>
<li>RNG state preservation for consistent randomized outcomes</li>
<li>Client-side prediction for responsive gameplay</li>
</ul>
<p>The rollback system integrates tightly with our deterministic RNG implementation to ensure that random events like shuffling and coin flips remain consistent across network boundaries, even during recovery from disruptions.</p>
<h2 id="testing-game-state-management"><a class="header" href="#testing-game-state-management">Testing Game State Management</a></h2>
<p>Testing the game state management system involves:</p>
<ol>
<li><strong>Unit Tests</strong>: Testing individual state components and transitions</li>
<li><strong>Integration Tests</strong>: Testing state synchronization across multiple clients</li>
<li><strong>Stress Tests</strong>: Testing state management under high load or poor network conditions</li>
</ol>
<p>For detailed testing procedures, see the <a href="networking/gameplay/state/../../testing/integration/strategy.html">Integration Testing Strategy</a>.</p>
<h2 id="future-enhancements-4"><a class="header" href="#future-enhancements-4">Future Enhancements</a></h2>
<p>Planned improvements to game state management include:</p>
<ul>
<li>Enhanced state compression for better network performance</li>
<li>More sophisticated state reconciliation algorithms</li>
<li>Support for game state snapshots and replays</li>
<li>Improved handling of complex card interactions</li>
</ul>
<hr />
<p>This documentation will be updated as game state management evolves.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-rollback-and-recovery"><a class="header" href="#state-rollback-and-recovery">State Rollback and Recovery</a></h1>
<p>This document outlines the implementation of state rollback and recovery mechanisms in our MTG Commander game engine, addressing network disruptions and maintaining gameplay integrity despite unstable connections.</p>
<h2 id="table-of-contents-11"><a class="header" href="#table-of-contents-11">Table of Contents</a></h2>
<ol>
<li><a href="networking/gameplay/state/rollback.html#overview">Overview</a></li>
<li><a href="networking/gameplay/state/rollback.html#rollback-architecture">Rollback Architecture</a></li>
<li><a href="networking/gameplay/state/rollback.html#state-snapshots">State Snapshots</a></li>
<li><a href="networking/gameplay/state/rollback.html#deterministic-replay">Deterministic Replay</a></li>
<li><a href="networking/gameplay/state/rollback.html#rng-synchronization-for-rollbacks">RNG Synchronization for Rollbacks</a></li>
<li><a href="networking/gameplay/state/rollback.html#client-side-prediction">Client-Side Prediction</a></li>
<li><a href="networking/gameplay/state/rollback.html#recovery-processes">Recovery Processes</a></li>
<li><a href="networking/gameplay/state/rollback.html#implementation-example">Implementation Example</a></li>
</ol>
<h2 id="overview-10"><a class="header" href="#overview-10">Overview</a></h2>
<p>In networked gameplay, unstable connections can lead to state inconsistencies between the server and clients. The state rollback system allows the game to:</p>
<ol>
<li>Detect state deviations</li>
<li>Revert to a previous valid state</li>
<li>Deterministically replay actions to catch up</li>
<li>Resume normal play without disrupting the game flow</li>
</ol>
<p>This approach is particularly important for turn-based games like MTG Commander where the integrity of game state is critical.</p>
<h2 id="rollback-architecture"><a class="header" href="#rollback-architecture">Rollback Architecture</a></h2>
<p>Our rollback architecture follows these principles:</p>
<ol>
<li><strong>Server Authority</strong>: The server maintains the authoritative game state</li>
<li><strong>State History</strong>: Both server and clients maintain a history of game states</li>
<li><strong>Deterministic Replay</strong>: Actions can be replayed deterministically to reconstruct state</li>
<li><strong>Input Buffering</strong>: Client inputs are buffered to handle resynchronization</li>
<li><strong>Minimal Disruption</strong>: Rollbacks should be as seamless as possible to players</li>
</ol>
<h3 id="component-integration"><a class="header" href="#component-integration">Component Integration</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/networking/state/rollback.rs
use bevy::prelude::*;
use bevy_prng::WyRand;
use bevy_rand::prelude::*;
use crate::networking::server::resources::GameServer;
use crate::game_engine::state::GameState;

/// Plugin for handling state rollbacks in networked games
pub struct StateRollbackPlugin;

impl Plugin for StateRollbackPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app.init_resource::&lt;StateHistory&gt;()
           .init_resource::&lt;ClientInputBuffer&gt;()
           .add_systems(Update, (
               create_state_snapshots,
               detect_state_deviations,
               handle_rollback_requests,
               apply_rollbacks,
           ));
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="state-snapshots-1"><a class="header" href="#state-snapshots-1">State Snapshots</a></h2>
<p>The core of our rollback system is the ability to capture and restore game state snapshots:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Resource for tracking game state history
#[derive(Resource)]
pub struct StateHistory {
    /// Timestamped state snapshots
    pub snapshots: Vec&lt;StateSnapshot&gt;,
    /// Maximum number of snapshots to retain
    pub max_snapshots: usize,
    /// Time between state snapshots (in seconds)
    pub snapshot_interval: f32,
    /// Last snapshot time
    pub last_snapshot_time: f32,
}

impl Default for StateHistory {
    fn default() -&gt; Self {
        Self {
            snapshots: Vec::new(),
            max_snapshots: 20, // Store up to 20 snapshots (~1 minute of gameplay at 3s intervals)
            snapshot_interval: 3.0, // Take a snapshot every 3 seconds
            last_snapshot_time: 0.0,
        }
    }
}

/// A complete snapshot of game state at a point in time
#[derive(Clone, Debug)]
pub struct StateSnapshot {
    /// Timestamp when this snapshot was created
    pub timestamp: f32,
    /// Unique sequence number
    pub sequence_id: u64,
    /// Serialized game state
    pub game_state: Vec&lt;u8&gt;,
    /// Serialized RNG state
    pub rng_state: Vec&lt;u8&gt;,
    /// Action sequence that led to this state
    pub action_sequence: Vec&lt;ActionRecord&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="creating-snapshots"><a class="header" href="#creating-snapshots">Creating Snapshots</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// System to periodically create game state snapshots
pub fn create_state_snapshots(
    mut state_history: ResMut&lt;StateHistory&gt;,
    game_state: Res&lt;GameState&gt;,
    global_rng: Res&lt;GlobalEntropy&lt;WyRand&gt;&gt;,
    time: Res&lt;Time&gt;,
    sequence_tracker: Res&lt;ActionSequence&gt;,
) {
    // Check if it's time for a new snapshot
    if time.elapsed_seconds() - state_history.last_snapshot_time &gt;= state_history.snapshot_interval {
        // Create new snapshot
        let snapshot = StateSnapshot {
            timestamp: time.elapsed_seconds(),
            sequence_id: sequence_tracker.current_sequence_id,
            game_state: serialize_game_state(&amp;game_state),
            rng_state: global_rng.try_serialize_state().unwrap_or_default(),
            action_sequence: sequence_tracker.recent_actions.clone(),
        };
        
        // Add to history
        state_history.snapshots.push(snapshot);
        state_history.last_snapshot_time = time.elapsed_seconds();
        
        // Trim history if needed
        if state_history.snapshots.len() &gt; state_history.max_snapshots {
            state_history.snapshots.remove(0);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="deterministic-replay"><a class="header" href="#deterministic-replay">Deterministic Replay</a></h2>
<p>To ensure consistent rollback behavior, all game actions must be deterministic and replayable:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Record of a game action for replay purposes
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ActionRecord {
    /// Unique sequence ID for this action
    pub sequence_id: u64,
    /// Player who initiated the action
    pub player_id: Entity,
    /// Timestamp when the action occurred
    pub timestamp: f32,
    /// The actual action
    pub action: GameAction,
}

/// System to replay actions after a rollback
pub fn replay_actions(
    mut commands: Commands,
    mut game_state: ResMut&lt;GameState&gt;,
    mut global_rng: ResMut&lt;GlobalEntropy&lt;WyRand&gt;&gt;,
    rollback_event: Res&lt;RollbackEvent&gt;,
    actions: Vec&lt;ActionRecord&gt;,
) {
    // Restore the game state and RNG to the rollback point
    deserialize_game_state(&amp;mut game_state, &amp;rollback_event.snapshot.game_state);
    global_rng.deserialize_state(&amp;rollback_event.snapshot.rng_state).expect("Failed to restore RNG state");
    
    // Replay all actions that occurred after the rollback point
    for action in actions {
        // Process each action in sequence
        apply_action(&amp;mut commands, &amp;mut game_state, &amp;mut global_rng, action);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rng-synchronization-for-rollbacks"><a class="header" href="#rng-synchronization-for-rollbacks">RNG Synchronization for Rollbacks</a></h2>
<p>The RNG state is critical for deterministic rollbacks. We extend our existing RNG synchronization to support rollbacks:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Resource to track RNG snapshots for rollback
#[derive(Resource)]
pub struct RngSnapshotHistory {
    /// History of RNG states indexed by sequence ID
    pub snapshots: HashMap&lt;u64, Vec&lt;u8&gt;&gt;,
    /// Maximum number of RNG snapshots to keep
    pub max_snapshots: usize,
}

impl Default for RngSnapshotHistory {
    fn default() -&gt; Self {
        Self {
            snapshots: HashMap::new(),
            max_snapshots: 100,
        }
    }
}

/// System to capture RNG state before randomized actions
pub fn capture_rng_before_randomized_action(
    sequence_tracker: Res&lt;ActionSequence&gt;,
    global_rng: Res&lt;GlobalEntropy&lt;WyRand&gt;&gt;,
    mut rng_history: ResMut&lt;RngSnapshotHistory&gt;,
) {
    // Save the current RNG state before a randomized action
    if let Some(serialized_state) = global_rng.try_serialize_state() {
        rng_history.snapshots.insert(sequence_tracker.current_sequence_id, serialized_state);
        
        // Clean up old snapshots if needed
        if rng_history.snapshots.len() &gt; rng_history.max_snapshots {
            // Find and remove oldest snapshot
            if let Some(oldest_key) = rng_history.snapshots.keys()
                .min()
                .copied() {
                rng_history.snapshots.remove(&amp;oldest_key);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="client-side-prediction"><a class="header" href="#client-side-prediction">Client-Side Prediction</a></h2>
<p>To minimize the perception of network issues, clients can implement prediction:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Resource to track client-side prediction state
#[derive(Resource)]
pub struct PredictionState {
    /// Actions predicted but not yet confirmed
    pub pending_actions: Vec&lt;ActionRecord&gt;,
    /// Whether prediction is currently active
    pub is_predicting: bool,
    /// Last confirmed server sequence ID
    pub last_confirmed_sequence: u64,
}

/// System to apply client-side prediction
pub fn apply_client_prediction(
    mut commands: Commands,
    mut game_state: ResMut&lt;GameState&gt;,
    mut prediction: ResMut&lt;PredictionState&gt;,
    input: Res&lt;Input&lt;KeyCode&gt;&gt;,
    client: Res&lt;GameClient&gt;,
) {
    // Only predict for local player actions
    if let Some(local_player) = client.local_player {
        // Check if a new action was input
        if input.just_pressed(KeyCode::Space) {
            // Example: Predict a "pass turn" action
            let action = GameAction::PassTurn { player: local_player };
            
            // Apply prediction locally
            apply_action_local(&amp;mut commands, &amp;mut game_state, action.clone());
            
            // Record the prediction
            prediction.pending_actions.push(ActionRecord {
                sequence_id: prediction.last_confirmed_sequence + prediction.pending_actions.len() as u64 + 1,
                player_id: local_player,
                timestamp: 0.0, // Will be filled by server
                action,
            });
            
            // Send to server
            // ...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="recovery-processes"><a class="header" href="#recovery-processes">Recovery Processes</a></h2>
<p>When a network issue is detected, the recovery process begins:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Event triggered when a rollback is needed
#[derive(Event)]
pub struct RollbackEvent {
    /// The snapshot to roll back to
    pub snapshot: StateSnapshot,
    /// Reason for the rollback
    pub reason: RollbackReason,
    /// Clients affected by this rollback
    pub affected_clients: Vec&lt;ClientId&gt;,
}

/// Reasons for triggering a rollback
#[derive(Debug, Clone, Copy)]
pub enum RollbackReason {
    /// State divergence detected
    StateDivergence,
    /// Client reconnected after disconnect
    ClientReconnection,
    /// Server-forced rollback
    ServerForced,
    /// Desync in randomized outcome
    RandomizationDesync,
}

/// System to handle client reconnection with state recovery
pub fn handle_client_reconnection(
    mut commands: Commands,
    mut server: ResMut&lt;GameServer&gt;,
    mut server_events: EventReader&lt;ServerEvent&gt;,
    state_history: Res&lt;StateHistory&gt;,
    mut rollback_events: EventWriter&lt;RollbackEvent&gt;,
    client_states: Res&lt;ClientStateTracker&gt;,
) {
    for event in server_events.read() {
        if let ServerEvent::ClientConnected { client_id } = event {
            // Check if this is a reconnection
            if let Some(player_entity) = server.client_player_map.get(client_id) {
                // Find last known state for this client
                if let Some(last_known_sequence) = client_states.get_last_sequence(*client_id) {
                    // Find appropriate snapshot to roll back to
                    if let Some(snapshot) = find_appropriate_snapshot(&amp;state_history, last_known_sequence) {
                        // Trigger rollback just for this client
                        rollback_events.send(RollbackEvent {
                            snapshot: snapshot.clone(),
                            reason: RollbackReason::ClientReconnection,
                            affected_clients: vec![*client_id],
                        });
                    }
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementation-example"><a class="header" href="#implementation-example">Implementation Example</a></h2>
<h3 id="complete-rollback-process"><a class="header" href="#complete-rollback-process">Complete Rollback Process</a></h3>
<p>This example shows a complete rollback process after detecting a state divergence:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// System to detect and handle state divergences
pub fn detect_state_divergences(
    mut commands: Commands,
    mut state_checksums: EventReader&lt;StateChecksumEvent&gt;,
    state_history: Res&lt;StateHistory&gt;,
    server: Option&lt;Res&lt;GameServer&gt;&gt;,
    mut rollback_events: EventWriter&lt;RollbackEvent&gt;,
) {
    // Only run on server
    if server.is_none() {
        return;
    }
    
    for checksum_event in state_checksums.read() {
        // Compare client checksum with server's expected checksum
        if checksum_event.client_checksum != checksum_event.expected_checksum {
            info!("State divergence detected for client {:?} at sequence {}",
                  checksum_event.client_id, checksum_event.sequence_id);
            
            // Find appropriate snapshot to roll back to
            if let Some(snapshot) = find_rollback_snapshot(&amp;state_history, checksum_event.sequence_id) {
                // Trigger rollback for the affected client
                rollback_events.send(RollbackEvent {
                    snapshot: snapshot.clone(),
                    reason: RollbackReason::StateDivergence,
                    affected_clients: vec![checksum_event.client_id],
                });
                
                // Log the rollback event
                info!("Initiating rollback to sequence {} for client {:?}",
                      snapshot.sequence_id, checksum_event.client_id);
            }
        }
    }
}

/// Find an appropriate snapshot for rollback
fn find_rollback_snapshot(history: &amp;StateHistory, divergence_sequence: u64) -&gt; Option&lt;&amp;StateSnapshot&gt; {
    // Find the most recent snapshot before the divergence
    history.snapshots
        .iter()
        .rev()
        .find(|snapshot| snapshot.sequence_id &lt; divergence_sequence)
}

/// Apply a rollback
pub fn apply_rollback(
    mut commands: Commands,
    mut game_state: ResMut&lt;GameState&gt;,
    mut global_rng: ResMut&lt;GlobalEntropy&lt;WyRand&gt;&gt;,
    mut rollback_events: EventReader&lt;RollbackEvent&gt;,
    action_history: Res&lt;ActionHistory&gt;,
) {
    for event in rollback_events.read() {
        // 1. Restore game state from snapshot
        deserialize_game_state(&amp;mut game_state, &amp;event.snapshot.game_state);
        
        // 2. Restore RNG state
        global_rng.deserialize_state(&amp;event.snapshot.rng_state)
            .expect("Failed to restore RNG state");
        
        // 3. Find actions that need to be replayed
        let actions_to_replay = action_history.get_actions_after(event.snapshot.sequence_id);
        
        // 4. Replay actions
        for action in actions_to_replay {
            apply_action(&amp;mut commands, &amp;mut game_state, &amp;mut global_rng, action.clone());
        }
        
        // 5. Notify clients of the rollback
        for client_id in &amp;event.affected_clients {
            commands.add(SendRollbackNotification {
                client_id: *client_id,
                snapshot: event.snapshot.clone(),
                reason: event.reason,
            });
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="handling-randomized-actions-during-rollback"><a class="header" href="#handling-randomized-actions-during-rollback">Handling Randomized Actions During Rollback</a></h3>
<p>Special consideration for randomized actions like card shuffling:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Apply an action during rollback replay
fn apply_action(
    commands: &amp;mut Commands,
    game_state: &amp;mut GameState,
    global_rng: &amp;mut GlobalEntropy&lt;WyRand&gt;,
    action: ActionRecord,
) {
    match &amp;action.action {
        GameAction::ShuffleLibrary { player, library } =&gt; {
            // For randomized actions, we need to ensure deterministic outcomes
            if let Ok(mut player_rng) = players.get_mut(action.player_id) {
                // Important: Use the RNG in a consistent way
                let mut library_entity = *library;
                let mut library_comp = game_state.get_library_mut(library_entity);
                
                // Deterministic shuffle using the player's RNG component
                library_comp.shuffle_with_rng(&amp;mut player_rng.rng);
            }
        },
        GameAction::FlipCoin { player } =&gt; {
            // Another example of randomized action
            if let Ok(mut player_rng) = players.get_mut(action.player_id) {
                // The random result will be the same as the original action
                // if the RNG state is properly restored
                let result = player_rng.rng.gen_bool(0.5);
                
                // Apply the result
                game_state.record_coin_flip(*player, result);
            }
        },
        // Handle other action types
        _ =&gt; {
            // Apply non-randomized actions normally
            game_state.apply_action(&amp;action.action);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-considerations"><a class="header" href="#real-world-considerations">Real-World Considerations</a></h2>
<p>In practice, a rollback system needs to balance several considerations:</p>
<ol>
<li><strong>Snapshot Frequency</strong>: More frequent snapshots use more memory but allow more precise rollbacks</li>
<li><strong>Rollback Visibility</strong>: How visible should rollbacks be to players?</li>
<li><strong>Partial vs. Full Rollbacks</strong>: Sometimes only a portion of the state needs rollback</li>
<li><strong>Action Batching</strong>: Batch multiple actions to minimize rollback frequency</li>
<li><strong>Bandwidth Costs</strong>: State synchronization requires bandwidth - optimize it</li>
</ol>
<h3 id="optimizing-for-mtg-commander"><a class="header" href="#optimizing-for-mtg-commander">Optimizing for MTG Commander</a></h3>
<p>For MTG Commander specifically:</p>
<ol>
<li>Take snapshots at natural game boundaries (turn changes, phase changes)</li>
<li>Use incremental state updates between major decision points</li>
<li>Maintain separate RNG state for "hidden information" actions like shuffling</li>
<li>Prioritize server authority for rule enforcement and dispute resolution</li>
<li>Enable client prediction for responsive UI during network hiccups</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-replicon-integration-for-rollback-with-rng-state-management"><a class="header" href="#bevy-replicon-integration-for-rollback-with-rng-state-management">Bevy Replicon Integration for Rollback with RNG State Management</a></h1>
<p>This document details the integration of bevy_replicon with our rollback system, focusing on maintaining RNG state consistency across the network.</p>
<h2 id="table-of-contents-12"><a class="header" href="#table-of-contents-12">Table of Contents</a></h2>
<ol>
<li><a href="networking/gameplay/state/replicon_rollback.html#introduction">Introduction</a></li>
<li><a href="networking/gameplay/state/replicon_rollback.html#replicon-and-rng-integration">Replicon and RNG Integration</a></li>
<li><a href="networking/gameplay/state/replicon_rollback.html#resources-and-components">Resources and Components</a></li>
<li><a href="networking/gameplay/state/replicon_rollback.html#systems-integration">Systems Integration</a></li>
<li><a href="networking/gameplay/state/replicon_rollback.html#state-preservation-and-recovery">State Preservation and Recovery</a></li>
<li><a href="networking/gameplay/state/replicon_rollback.html#implementation-examples">Implementation Examples</a></li>
<li><a href="networking/gameplay/state/replicon_rollback.html#performance-considerations">Performance Considerations</a></li>
<li><a href="networking/gameplay/state/replicon_rollback.html#testing-guidelines">Testing Guidelines</a></li>
</ol>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>bevy_replicon is a lightweight, ECS-friendly networking library that provides replication for Bevy games. While it handles much of the complexity of network synchronization, maintaining deterministic RNG state during rollbacks requires additional mechanisms.</p>
<p>This document outlines how we extend bevy_replicon to handle RNG state management during network disruptions, ensuring all clients maintain identical random number sequences after recovery.</p>
<h2 id="replicon-and-rng-integration"><a class="header" href="#replicon-and-rng-integration">Replicon and RNG Integration</a></h2>
<p>The key challenge is integrating bevy_replicon's entity replication with our RNG management system, particularly when:</p>
<ol>
<li>Replicating randomized game actions</li>
<li>Handling rollbacks after connection interruptions</li>
<li>Ensuring newly connected clients receive the correct RNG state</li>
<li>Maintaining determinism during complex game scenarios</li>
</ol>
<p>Our solution uses bevy_replicon's server-authoritative model but adds RNG state tracking and distribution mechanisms.</p>
<h3 id="architectural-overview"><a class="header" href="#architectural-overview">Architectural Overview</a></h3>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                           SERVER                                         ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ               ‚îÇ     ‚îÇ                  ‚îÇ     ‚îÇ                    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  REPLICON     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  RNG STATE       ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  GAME STATE       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  SERVER       ‚îÇ     ‚îÇ  MANAGER         ‚îÇ     ‚îÇ  MANAGER          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ               ‚îÇ     ‚îÇ                  ‚îÇ     ‚îÇ                    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ          ‚îÇ                       ‚îÇ                       ‚îÇ              ‚îÇ
‚îÇ          ‚îÇ                       ‚îÇ                       ‚îÇ              ‚îÇ
‚îÇ          ‚ñº                       ‚ñº                       ‚ñº              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ               ‚îÇ     ‚îÇ                  ‚îÇ     ‚îÇ                    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  REPLICON     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  ROLLBACK       ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ  SEQUENCE          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  REPLICATION  ‚îÇ     ‚îÇ  COORDINATOR    ‚îÇ     ‚îÇ  TRACKER           ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ               ‚îÇ     ‚îÇ                  ‚îÇ     ‚îÇ                    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚îÇ
                                    ‚îÇ
                                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                           CLIENT                                         ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ               ‚îÇ     ‚îÇ                  ‚îÇ     ‚îÇ                    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  REPLICON     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  RNG STATE       ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  GAME STATE       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  CLIENT       ‚îÇ     ‚îÇ  APPLIER         ‚îÇ     ‚îÇ  RECEIVER         ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ               ‚îÇ     ‚îÇ                  ‚îÇ     ‚îÇ                    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ          ‚îÇ                       ‚îÇ                       ‚îÇ              ‚îÇ
‚îÇ          ‚îÇ                       ‚îÇ                       ‚îÇ              ‚îÇ
‚îÇ          ‚ñº                       ‚ñº                       ‚ñº              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ               ‚îÇ     ‚îÇ                  ‚îÇ     ‚îÇ                    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  LOCAL        ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  PREDICTION     ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ  HISTORY           ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  RNG MANAGER  ‚îÇ     ‚îÇ  RECONCILIATION ‚îÇ     ‚îÇ  TRACKER           ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ               ‚îÇ     ‚îÇ                  ‚îÇ     ‚îÇ                    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h2 id="resources-and-components"><a class="header" href="#resources-and-components">Resources and Components</a></h2>
<h3 id="core-resources"><a class="header" href="#core-resources">Core Resources</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Resource that tracks RNG state for replication
#[derive(Resource)]
pub struct RngReplicationState {
    /// Current global RNG state
    pub global_state: Vec&lt;u8&gt;,
    /// Player-specific RNG states
    pub player_states: HashMap&lt;Entity, Vec&lt;u8&gt;&gt;,
    /// Sequence number for the latest RNG state update
    pub sequence: u64,
    /// Timestamp of the last update
    pub last_update: f32,
    /// Flag indicating the state has changed
    pub dirty: bool,
}

/// Resource for rollback checkpoints with RNG state
#[derive(Resource)]
pub struct RollbackCheckpoints {
    /// Checkpoints with sequence IDs as keys
    pub checkpoints: BTreeMap&lt;u64, RollbackCheckpoint&gt;,
    /// Maximum number of checkpoints to maintain
    pub max_checkpoints: usize,
}

/// Structure for a single rollback checkpoint
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct RollbackCheckpoint {
    /// Checkpoint sequence ID
    pub sequence_id: u64,
    /// Timestamp of the checkpoint
    pub timestamp: f32,
    /// Global RNG state
    pub global_rng_state: Vec&lt;u8&gt;,
    /// Player-specific RNG states
    pub player_rng_states: HashMap&lt;Entity, Vec&lt;u8&gt;&gt;,
    /// Replicated entities snapshot
    pub replicated_entities: Vec&lt;EntityData&gt;,
}

/// Replicon channel for RNG synchronization
#[derive(Default)]
pub struct RngSyncChannel;

/// Extension for RepliconServer to handle RNG state
impl RepliconServerExt for RepliconServer {
    /// Send RNG state to a specific client
    fn send_rng_state(&amp;mut self, client_id: ClientId, rng_state: &amp;RngReplicationState) {
        let message = RngStateMessage {
            global_state: rng_state.global_state.clone(),
            player_states: rng_state.player_states.clone(),
            sequence: rng_state.sequence,
            timestamp: rng_state.last_update,
        };
        
        self.send_message(client_id, RngSyncChannel, bincode::serialize(&amp;message).unwrap());
    }
    
    /// Broadcast RNG state to all clients
    fn broadcast_rng_state(&amp;mut self, rng_state: &amp;RngReplicationState) {
        let message = RngStateMessage {
            global_state: rng_state.global_state.clone(),
            player_states: rng_state.player_states.clone(),
            sequence: rng_state.sequence,
            timestamp: rng_state.last_update,
        };
        
        self.broadcast_message(RngSyncChannel, bincode::serialize(&amp;message).unwrap());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="components-for-entity-tracking"><a class="header" href="#components-for-entity-tracking">Components for Entity Tracking</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Component to flag an entity as having randomized behavior
#[derive(Component, Reflect, Default)]
pub struct RandomizedBehavior {
    /// The last RNG sequence ID used for this entity
    pub last_rng_sequence: u64,
    /// Whether this entity has pending randomized actions
    pub has_pending_actions: bool,
}

/// Component for player-specific RNG
#[derive(Component, Reflect)]
pub struct PlayerRng {
    /// Sequence of the last RNG state
    pub sequence: u64,
    /// Whether this RNG is remote (on another client)
    pub is_remote: bool,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="systems-integration"><a class="header" href="#systems-integration">Systems Integration</a></h2>
<h3 id="server-side-systems"><a class="header" href="#server-side-systems">Server-Side Systems</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Plugin that integrates bevy_replicon with our RNG and rollback systems
pub struct RepliconRngRollbackPlugin;

impl Plugin for RepliconRngRollbackPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        // Register network channel
        app.register_network_channel::&lt;RngSyncChannel&gt;(ChannelConfig {
            channel_id: 100, // Use a unique channel ID
            mode: ChannelMode::Unreliable,
        });
        
        // Add resources
        app.init_resource::&lt;RngReplicationState&gt;()
            .init_resource::&lt;RollbackCheckpoints&gt;();
            
        // Server systems
        app.add_systems(Update, (
            capture_rng_state,
            replicate_rng_state,
            create_rollback_checkpoints,
        ).run_if(resource_exists::&lt;RepliconServer&gt;()));
        
        // Client systems
        app.add_systems(Update, (
            apply_rng_state_updates,
            handle_rollback_requests,
        ).run_if(resource_exists::&lt;RepliconClient&gt;()));
    }
}

/// System to capture RNG state for replication
pub fn capture_rng_state(
    mut global_rng: ResMut&lt;GlobalEntropy&lt;WyRand&gt;&gt;,
    player_rngs: Query&lt;(Entity, &amp;PlayerRng)&gt;,
    mut rng_state: ResMut&lt;RngReplicationState&gt;,
    time: Res&lt;Time&gt;,
    sequence: Res&lt;SequenceTracker&gt;,
) {
    // Don't update too frequently
    if time.elapsed_seconds() - rng_state.last_update &lt; 1.0 {
        return;
    }
    
    // Capture global RNG state
    if let Some(state) = global_rng.try_serialize_state() {
        rng_state.global_state = state;
        rng_state.dirty = true;
    }
    
    // Capture player RNG states
    for (entity, _) in player_rngs.iter() {
        if let Some(player_rng) = player_rngs.get_component::&lt;Entropy&lt;WyRand&gt;&gt;(entity).ok() {
            if let Some(state) = player_rng.try_serialize_state() {
                rng_state.player_states.insert(entity, state);
                rng_state.dirty = true;
            }
        }
    }
    
    if rng_state.dirty {
        rng_state.sequence = sequence.current_sequence;
        rng_state.last_update = time.elapsed_seconds();
    }
}

/// System to replicate RNG state to clients
pub fn replicate_rng_state(
    mut server: ResMut&lt;RepliconServer&gt;,
    rng_state: Res&lt;RngReplicationState&gt;,
) {
    if rng_state.dirty {
        server.broadcast_rng_state(&amp;rng_state);
    }
}

/// System to create rollback checkpoints
pub fn create_rollback_checkpoints(
    mut checkpoints: ResMut&lt;RollbackCheckpoints&gt;,
    rng_state: Res&lt;RngReplicationState&gt;,
    time: Res&lt;Time&gt;,
    replicated_query: Query&lt;Entity, With&lt;Replication&gt;&gt;,
    entity_data: Res&lt;EntityData&gt;,
) {
    // Create a new checkpoint every few seconds
    if time.elapsed_seconds() % 5.0 &lt; 0.1 {
        // Collect replicated entity data
        let mut entities = Vec::new();
        for entity in replicated_query.iter() {
            if let Some(data) = entity_data.get_entity_data(entity) {
                entities.push(data.clone());
            }
        }
        
        // Create checkpoint
        let checkpoint = RollbackCheckpoint {
            sequence_id: rng_state.sequence,
            timestamp: time.elapsed_seconds(),
            global_rng_state: rng_state.global_state.clone(),
            player_rng_states: rng_state.player_states.clone(),
            replicated_entities: entities,
        };
        
        // Add to checkpoints
        checkpoints.checkpoints.insert(rng_state.sequence, checkpoint);
        
        // Prune old checkpoints
        while checkpoints.checkpoints.len() &gt; checkpoints.max_checkpoints {
            if let Some((&amp;oldest_key, _)) = checkpoints.checkpoints.iter().next() {
                checkpoints.checkpoints.remove(&amp;oldest_key);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="client-side-systems"><a class="header" href="#client-side-systems">Client-Side Systems</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// System to apply RNG state updates from server
pub fn apply_rng_state_updates(
    mut client: ResMut&lt;RepliconClient&gt;,
    mut global_rng: ResMut&lt;GlobalEntropy&lt;WyRand&gt;&gt;,
    mut player_rngs: Query&lt;(Entity, &amp;mut PlayerRng)&gt;,
    mut events: EventReader&lt;NetworkEvent&gt;,
) {
    for event in events.read() {
        if let NetworkEvent::Message(_, RngSyncChannel, data) = event {
            // Deserialize the RNG state message
            if let Ok(message) = bincode::deserialize::&lt;RngStateMessage&gt;(data) {
                // Apply global RNG state
                if !message.global_state.is_empty() {
                    global_rng.deserialize_state(&amp;message.global_state)
                        .expect("Failed to deserialize global RNG state");
                }
                
                // Apply player-specific RNG states
                for (entity, mut player_rng) in player_rngs.iter_mut() {
                    if let Some(state) = message.player_states.get(&amp;entity) {
                        if let Some(rng) = player_rngs.get_component_mut::&lt;Entropy&lt;WyRand&gt;&gt;(entity).ok() {
                            rng.deserialize_state(state).expect("Failed to deserialize player RNG state");
                            player_rng.sequence = message.sequence;
                        }
                    }
                }
            }
        }
    }
}

/// System to handle rollback requests
pub fn handle_rollback_requests(
    mut client: ResMut&lt;RepliconClient&gt;,
    mut global_rng: ResMut&lt;GlobalEntropy&lt;WyRand&gt;&gt;,
    mut player_rngs: Query&lt;(Entity, &amp;mut PlayerRng)&gt;,
    mut events: EventReader&lt;NetworkEvent&gt;,
    mut commands: Commands,
) {
    for event in events.read() {
        if let NetworkEvent::Message(_, RollbackChannel, data) = event {
            // Deserialize the rollback message
            if let Ok(message) = bincode::deserialize::&lt;RollbackMessage&gt;(data) {
                // Apply global RNG state from the checkpoint
                if !message.checkpoint.global_rng_state.is_empty() {
                    global_rng.deserialize_state(&amp;message.checkpoint.global_rng_state)
                        .expect("Failed to deserialize checkpoint RNG state");
                }
                
                // Apply player-specific RNG states from the checkpoint
                for (entity, mut player_rng) in player_rngs.iter_mut() {
                    if let Some(state) = message.checkpoint.player_rng_states.get(&amp;entity) {
                        if let Some(rng) = player_rngs.get_component_mut::&lt;Entropy&lt;WyRand&gt;&gt;(entity).ok() {
                            rng.deserialize_state(state).expect("Failed to deserialize player RNG state");
                            player_rng.sequence = message.checkpoint.sequence_id;
                        }
                    }
                }
                
                // Restore entity state from checkpoint
                for entity_data in &amp;message.checkpoint.replicated_entities {
                    // Restore entity or spawn if it doesn't exist
                    // ...
                }
                
                info!("Applied rollback to sequence {}", message.checkpoint.sequence_id);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="state-preservation-and-recovery"><a class="header" href="#state-preservation-and-recovery">State Preservation and Recovery</a></h2>
<p>The rollback process occurs in these steps:</p>
<ol>
<li><strong>Detection</strong>: Server detects desynchronization (via mismatch in action results)</li>
<li><strong>Checkpoint Selection</strong>: Server selects appropriate rollback checkpoint</li>
<li><strong>Notification</strong>: Server notifies affected clients of rollback</li>
<li><strong>State Restoration</strong>: Both server and clients:
<ul>
<li>Restore game state</li>
<li>Restore RNG state</li>
<li>Replay necessary actions</li>
</ul>
</li>
<li><strong>Verification</strong>: Server verifies all clients are synchronized</li>
</ol>
<h3 id="rollback-protocol"><a class="header" href="#rollback-protocol">Rollback Protocol</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Enum for rollback types
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum RollbackType {
    /// Full rollback with complete state restoration
    Full,
    /// Partial rollback for specific entities only
    Partial,
    /// RNG-only rollback for randomization issues
    RngOnly,
}

/// Message for rollback requests
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RollbackMessage {
    /// Type of rollback
    pub rollback_type: RollbackType,
    /// Rollback checkpoint
    pub checkpoint: RollbackCheckpoint,
    /// Reason for rollback
    pub reason: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementation-examples"><a class="header" href="#implementation-examples">Implementation Examples</a></h2>
<h3 id="example-1-rollback-after-network-interruption"><a class="header" href="#example-1-rollback-after-network-interruption">Example 1: Rollback After Network Interruption</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// System to detect and handle network interruptions
pub fn handle_network_interruption(
    mut server: ResMut&lt;RepliconServer&gt;,
    checkpoints: Res&lt;RollbackCheckpoints&gt;,
    clients: Query&lt;(Entity, &amp;ClientConnection)&gt;,
    time: Res&lt;Time&gt;,
) {
    // Check for clients with high latency or disconnection
    for (entity, connection) in clients.iter() {
        if connection.latency &gt; 1.0 || !connection.connected {
            // Find most recent valid checkpoint
            if let Some((_, checkpoint)) = checkpoints.checkpoints.iter().rev().next() {
                // Initiate rollback for all clients
                let rollback_message = RollbackMessage {
                    rollback_type: RollbackType::Full,
                    checkpoint: checkpoint.clone(),
                    reason: "Network interruption detected".to_string(),
                };
                
                // Send to all clients
                server.broadcast_message(RollbackChannel, bincode::serialize(&amp;rollback_message).unwrap());
                
                // Apply rollback on server too
                apply_rollback_on_server(&amp;rollback_message);
                
                info!("Initiated rollback due to network interruption");
            }
            break;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="example-2-handling-card-shuffle-during-rollback"><a class="header" href="#example-2-handling-card-shuffle-during-rollback">Example 2: Handling Card Shuffle During Rollback</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// System to handle card shuffling during or after a rollback
pub fn handle_shuffle_during_rollback(
    mut commands: Commands,
    mut shuffle_events: EventReader&lt;ShuffleLibraryEvent&gt;,
    mut global_rng: ResMut&lt;GlobalEntropy&lt;WyRand&gt;&gt;,
    player_rngs: Query&lt;(Entity, &amp;PlayerRng)&gt;,
    libraries: Query&lt;(Entity, &amp;Library, &amp;Parent)&gt;,
) {
    for event in shuffle_events.read() {
        if let Ok((library_entity, library, parent)) = libraries.get(event.library_entity) {
            // Get the player entity (parent)
            let player_entity = parent.get();
            
            // Get player's RNG
            if let Ok((_, player_rng)) = player_rngs.get(player_entity) {
                // Use the appropriate RNG for deterministic shuffle
                let mut card_indices: Vec&lt;usize&gt; = (0..library.cards.len()).collect();
                
                if player_rng.is_remote {
                    // Use global RNG for remote player to ensure consistency
                    for i in (1..card_indices.len()).rev() {
                        let j = global_rng.gen_range(0..=i);
                        card_indices.swap(i, j);
                    }
                } else {
                    // Use player-specific RNG for local player
                    if let Some(rng) = player_rngs.get_component::&lt;Entropy&lt;WyRand&gt;&gt;(player_entity).ok() {
                        for i in (1..card_indices.len()).rev() {
                            let j = rng.gen_range(0..=i);
                            card_indices.swap(i, j);
                        }
                    }
                }
                
                // Apply shuffle result
                // ...
                
                info!("Performed deterministic shuffle during/after rollback");
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<p>When implementing RNG state management with bevy_replicon and rollbacks, consider these performance factors:</p>
<ol>
<li>
<p><strong>RNG State Size</strong>:</p>
<ul>
<li>WyRand has a compact 8-byte state, ideal for frequent replication</li>
<li>More complex PRNGs may have larger states, increasing network overhead</li>
</ul>
</li>
<li>
<p><strong>Checkpoint Frequency</strong>:</p>
<ul>
<li>More frequent checkpoints = better recovery granularity but higher overhead</li>
<li>Recommended: 5-10 second intervals for most games</li>
</ul>
</li>
<li>
<p><strong>Selective Replication</strong>:</p>
<ul>
<li>Only replicate RNG state when it changes significantly</li>
<li>Consider checksums to detect state changes efficiently</li>
</ul>
</li>
<li>
<p><strong>Bandwidth Usage</strong>:</p>
<ul>
<li>Use the appropriate channel mode (reliable for critical RNG updates)</li>
<li>Batch RNG updates with other state replication when possible</li>
</ul>
</li>
<li>
<p><strong>Memory Overhead</strong>:</p>
<ul>
<li>Limit maximum checkpoints based on available memory (10-20 is reasonable)</li>
<li>Use sliding window approach to discard old checkpoints</li>
</ul>
</li>
</ol>
<h2 id="testing-guidelines"><a class="header" href="#testing-guidelines">Testing Guidelines</a></h2>
<p>For effective testing of replicon-based RNG rollback, follow these approaches:</p>
<ol>
<li>
<p><strong>Determinism Tests</strong>:</p>
<ul>
<li>Verify identical seeds produce identical sequences on all clients</li>
<li>Test saving and restoring RNG state produces identical future values</li>
</ul>
</li>
<li>
<p><strong>Network Disruption Tests</strong>:</p>
<ul>
<li>Simulate connection drops to trigger rollback</li>
<li>Verify game state remains consistent after recovery</li>
</ul>
</li>
<li>
<p><strong>Performance Tests</strong>:</p>
<ul>
<li>Measure impact of RNG state replication on bandwidth</li>
<li>Profile checkpoint creation and restoration overhead</li>
</ul>
</li>
<li>
<p><strong>Integration Tests</strong>:</p>
<ul>
<li>Test complex game scenarios like multi-player card shuffling</li>
<li>Verify random outcomes remain consistent across network boundaries</li>
</ul>
</li>
</ol>
<p>For detailed testing examples, see the <a href="networking/gameplay/state/../../testing/rng_synchronization_tests.html">RNG Synchronization Tests</a> document.</p>
<hr />
<p>By following these guidelines, you can create a robust integration between bevy_replicon, our rollback system, and RNG state management that maintains deterministic behavior even during network disruptions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comprehensive-testing-guide-for-mtg-commander-online"><a class="header" href="#comprehensive-testing-guide-for-mtg-commander-online">Comprehensive Testing Guide for MTG Commander Online</a></h1>
<p>This document serves as the central index for all testing documentation related to our networked MTG Commander implementation. It provides an overview of our testing strategy and links to detailed documentation for specific testing areas.</p>
<h2 id="core-principles"><a class="header" href="#core-principles">Core Principles</a></h2>
<p>Our testing strategy for the online MTG Commander implementation is built on the following core principles:</p>
<ol>
<li><strong>Comprehensive Coverage</strong>: Testing all aspects of the system, from individual components to full end-to-end gameplay</li>
<li><strong>Realism</strong>: Simulating real-world conditions, including varied network environments and player behaviors</li>
<li><strong>Automation</strong>: Maximizing the use of automated testing to enable frequent regression testing</li>
<li><strong>Game Rule Compliance</strong>: Ensuring the implementation adheres to all Commander format rules</li>
<li><strong>Security</strong>: Verifying that hidden information remains appropriately hidden</li>
<li><strong>Performance</strong>: Validating that the system functions well under various loads and conditions</li>
</ol>
<h2 id="testing-documentation-structure"><a class="header" href="#testing-documentation-structure">Testing Documentation Structure</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Document</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="networking/testing/testing.html">Core Testing Strategy</a></td><td>Outlines the fundamental approach to testing the networking implementation</td></tr>
<tr><td><a href="networking/testing/testing_advanced.html">Advanced Testing Strategies</a></td><td>Covers specialized testing approaches for Commander-specific needs</td></tr>
<tr><td><a href="networking/testing/integration_testing.html">Integration Testing</a></td><td>Details testing at the boundary between networking and game engine</td></tr>
<tr><td><a href="networking/testing/security_testing.html">Security Testing</a></td><td>Approaches for testing information hiding and anti-cheat mechanisms</td></tr>
</tbody></table>
</div>
<h2 id="testing-types"><a class="header" href="#testing-types">Testing Types</a></h2>
<h3 id="unit-testing-1"><a class="header" href="#unit-testing-1">Unit Testing</a></h3>
<p>Unit tests focus on individual components in isolation:</p>
<ul>
<li>Networking protocol components</li>
<li>State synchronization mechanisms</li>
<li>Game rule implementation</li>
<li>Command processing</li>
</ul>
<h3 id="integration-testing-1"><a class="header" href="#integration-testing-1">Integration Testing</a></h3>
<p>Integration tests verify components work together correctly:</p>
<ul>
<li>Networking and game state management</li>
<li>Client/server communication</li>
<li>Action validation and execution</li>
<li>Priority and turn handling</li>
</ul>
<h3 id="system-testing"><a class="header" href="#system-testing">System Testing</a></h3>
<p>System tests examine the complete system's functionality:</p>
<ul>
<li>Full game scenarios</li>
<li>Multiple players</li>
<li>Complete turn cycles</li>
<li>Commander-specific rules</li>
</ul>
<h3 id="network-simulation-testing"><a class="header" href="#network-simulation-testing">Network Simulation Testing</a></h3>
<p>Tests under various network conditions:</p>
<ul>
<li>High latency</li>
<li>Packet loss</li>
<li>Jitter</li>
<li>Bandwidth limitations</li>
<li>Server/client disconnection and reconnection</li>
</ul>
<h2 id="test-implementation-guidance"><a class="header" href="#test-implementation-guidance">Test Implementation Guidance</a></h2>
<p>When implementing tests, follow these guidelines:</p>
<ol>
<li><strong>Test Isolation</strong>: Each test should run independently without relying on state from other tests</li>
<li><strong>Determinism</strong>: Tests should produce consistent results when run multiple times with the same inputs</li>
<li><strong>Clear Assertions</strong>: Use descriptive assertion messages that explain what is being tested and why it failed</li>
<li><strong>Comprehensive Verification</strong>: Verify all relevant aspects of state after actions, not just one element</li>
<li><strong>Cleanup</strong>: Tests should clean up after themselves to avoid interfering with other tests</li>
</ol>
<h2 id="test-data-management"><a class="header" href="#test-data-management">Test Data Management</a></h2>
<p>Standard test fixtures are available for:</p>
<ul>
<li>Player configurations</li>
<li>Deck compositions</li>
<li>Board states</li>
<li>Game scenarios</li>
</ul>
<p>Use the <code>TestDataRepository</code> to access these fixtures:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example of using test fixtures
#[test]
fn test_combat_interaction() {
    let mut app = setup_test_app();
    
    // Load a predefined mid-game state with creatures
    let test_state = TestDataRepository::load_fixture("mid_game_combat_state");
    setup_game_state(&amp;mut app, &amp;test_state);
    
    // Execute test
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h2>
<p>Our CI pipeline automatically runs the following test suites:</p>
<ol>
<li><strong>Unit Tests</strong>: On every push and pull request</li>
<li><strong>Integration Tests</strong>: On every push and pull request</li>
<li><strong>System Tests</strong>: On every push to main or develop branches</li>
<li><strong>Security Tests</strong>: Nightly on develop branch</li>
<li><strong>Network Simulation Tests</strong>: Nightly on develop branch</li>
</ol>
<p>Test results are available in the CI dashboard, including:</p>
<ul>
<li>Test pass/fail status</li>
<li>Performance benchmarks</li>
<li>Coverage reports</li>
<li>Network simulation metrics</li>
</ul>
<h2 id="local-testing-workflow"><a class="header" href="#local-testing-workflow">Local Testing Workflow</a></h2>
<p>To run tests locally:</p>
<pre><code class="language-bash"># Run unit tests
cargo test networking::unit

# Run integration tests
cargo test networking::integration

# Run system tests
cargo test networking::system

# Run security tests
cargo test networking::security

# Run network simulation tests
cargo test networking::simulation
</code></pre>
<p>For more detailed output:</p>
<pre><code class="language-bash">cargo test networking::integration -- --nocapture --test-threads=1
</code></pre>
<h2 id="additional-testing-resources"><a class="header" href="#additional-testing-resources">Additional Testing Resources</a></h2>
<ul>
<li><a href="https://bevyengine.org/learn/book/getting-started/testing/">Bevy Testing Guide</a></li>
<li><a href="https://github.com/jakobhellermann/bevy_replicon/wiki/testing">Replicon Network Testing</a></li>
<li><a href="https://asatarin.github.io/testing-distributed-systems/">Testing Distributed Systems</a></li>
<li><a href="https://github.com/MFatihMAR/Game-Networking-Resources">Game Networking Resources</a></li>
</ul>
<h2 id="contributing-new-tests"><a class="header" href="#contributing-new-tests">Contributing New Tests</a></h2>
<p>When adding new tests:</p>
<ol>
<li>Identify the appropriate category for your test</li>
<li>Follow the existing naming conventions</li>
<li>Add detailed comments explaining the test purpose and expected behavior</li>
<li>Update test documentation if adding new test categories</li>
<li>Ensure tests run within a reasonable timeframe</li>
</ol>
<hr />
<p>By following this comprehensive testing strategy, we can ensure our networked MTG Commander implementation is robust, performant, and faithful to the rules of the game. Our testing suite provides confidence that the game will work correctly across a variety of real-world conditions and player interactions.</p>
<h1 id="networking-testing-documentation"><a class="header" href="#networking-testing-documentation">Networking Testing Documentation</a></h1>
<p>This section provides comprehensive documentation on testing methodologies for our networked MTG Commander game engine.</p>
<h2 id="testing-overview"><a class="header" href="#testing-overview">Testing Overview</a></h2>
<p>Testing networked applications presents unique challenges due to:</p>
<ol>
<li><strong>Variable Network Conditions</strong>: Latency, packet loss, and disconnections</li>
<li><strong>State Synchronization</strong>: Ensuring all clients see the same game state</li>
<li><strong>Randomization Consistency</strong>: Maintaining deterministic behavior across network boundaries</li>
<li><strong>Security Concerns</strong>: Preventing cheating and unauthorized access</li>
</ol>
<p>Our testing approach addresses these challenges through a multi-layered strategy, combining unit tests, integration tests, and end-to-end tests with specialized tools for network simulation.</p>
<h2 id="testing-categories"><a class="header" href="#testing-categories">Testing Categories</a></h2>
<h3 id="unit-tests-4"><a class="header" href="#unit-tests-4">Unit Tests</a></h3>
<p>Unit tests verify individual components and systems in isolation:</p>
<ul>
<li><a href="networking/testing/overview.html#unit-tests">Basic Network Component Tests</a></li>
<li><a href="networking/testing/rng_synchronization_tests.html#unit-tests">RNG Synchronization Unit Tests</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#unit-tests">Replicon RNG Integration Tests</a></li>
</ul>
<h3 id="integration-tests-4"><a class="header" href="#integration-tests-4">Integration Tests</a></h3>
<p>Integration tests verify that multiple components work together correctly:</p>
<ul>
<li><a href="networking/testing/integration/strategy.html#client-server-integration">Client-Server Integration</a></li>
<li><a href="networking/testing/overview.html#game-state-synchronization-tests">Game State Synchronization</a></li>
<li><a href="networking/testing/rng_synchronization_tests.html#integration-tests">RNG Integration Tests</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#integration-tests">Replicon RNG Integration Tests</a></li>
</ul>
<h3 id="end-to-end-tests"><a class="header" href="#end-to-end-tests">End-to-End Tests</a></h3>
<p>End-to-end tests verify complete game scenarios from start to finish:</p>
<ul>
<li><a href="networking/testing/overview.html#full-game-scenarios">Full Game Scenarios</a></li>
<li><a href="networking/testing/advanced_techniques.html#network-disruption-testing">Network Disruption Tests</a></li>
<li><a href="networking/testing/overview.html#card-interaction-tests">Card Interactions Over Network</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#end-to-end-tests">Replicon Rollback Tests</a></li>
</ul>
<h3 id="performance-tests-2"><a class="header" href="#performance-tests-2">Performance Tests</a></h3>
<p>Performance tests measure the efficiency and scalability of our networking code:</p>
<ul>
<li><a href="networking/testing/advanced_techniques.html#bandwidth-testing">Bandwidth Utilization</a></li>
<li><a href="networking/testing/advanced_techniques.html#latency-testing">Latency Impact</a></li>
<li><a href="networking/testing/advanced_techniques.html#scaling-tests">Scaling Tests</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#performance-tests">RNG State Replication Performance</a></li>
</ul>
<h3 id="security-tests"><a class="header" href="#security-tests">Security Tests</a></h3>
<p>Security tests verify that our game is resistant to cheating and unauthorized access:</p>
<ul>
<li><a href="networking/testing/security/strategy.html#authentication-tests">Authentication Testing</a></li>
<li><a href="networking/testing/security/strategy.html#authorization-tests">Authorization Tests</a></li>
<li><a href="networking/testing/security/strategy.html#anti-cheat-tests">Anti-Cheat Verification</a></li>
<li><a href="networking/testing/security/strategy.html#hidden-information-tests">Hidden Information Protection</a></li>
</ul>
<h2 id="test-implementation-guide"><a class="header" href="#test-implementation-guide">Test Implementation Guide</a></h2>
<p>When implementing tests for our networked MTG Commander game, follow these guidelines:</p>
<ol>
<li><strong>Test Each Layer</strong>: Test network communication, state synchronization, and game logic separately</li>
<li><strong>Simulate Real Conditions</strong>: Use network simulators to test under realistic conditions</li>
<li><strong>Automation</strong>: Automate as many tests as possible for continuous integration</li>
<li><strong>Determinism</strong>: Ensure tests are deterministic and repeatable</li>
<li><strong>RNG Testing</strong>: Pay special attention to randomized game actions</li>
</ol>
<h2 id="testing-tools"><a class="header" href="#testing-tools">Testing Tools</a></h2>
<p>Our testing infrastructure includes these specialized tools:</p>
<ol>
<li><strong>Network Simulators</strong>: Tools to simulate various network conditions</li>
<li><strong>Test Harnesses</strong>: Specialized test environments for network testing</li>
<li><strong>RNG Test Utilities</strong>: Tools for verifying random number determinism</li>
<li><strong>Benchmarking Tools</strong>: Performance measurement utilities</li>
</ol>
<h2 id="key-test-scenarios"><a class="header" href="#key-test-scenarios">Key Test Scenarios</a></h2>
<p>Ensure these critical scenarios are thoroughly tested:</p>
<ol>
<li><strong>Client Connection/Disconnection</strong>: Test proper handling of clients joining and leaving</li>
<li><strong>State Synchronization</strong>: Verify all clients see the same game state</li>
<li><strong>Randomized Actions</strong>: Test that shuffling, coin flips, etc. are deterministic</li>
<li><strong>Network Disruption</strong>: Test recovery after connection issues</li>
<li><strong>Latency Compensation</strong>: Test playability under various latency conditions</li>
</ol>
<h2 id="testing-rng-with-replicon"><a class="header" href="#testing-rng-with-replicon">Testing RNG with Replicon</a></h2>
<p>Our new approach using bevy_replicon for RNG state management requires specialized testing:</p>
<ul>
<li><a href="networking/testing/replicon_rng_tests.html">Replicon RNG Testing Overview</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#testing-rng-state-serialization-and-deserialization">RNG State Serialization Tests</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#testing-checkpoint-creation-and-restoration">Checkpoint Testing</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#testing-rollback-due-to-network-disruption">Network Disruption Recovery</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#testing-card-shuffling-during-network-disruption">Card Shuffling Tests</a></li>
</ul>
<h2 id="test-fixtures-and-harnesses"><a class="header" href="#test-fixtures-and-harnesses">Test Fixtures and Harnesses</a></h2>
<p>We provide several test fixtures to simplify test implementation:</p>
<ul>
<li><a href="networking/testing/overview.html#test-fixtures">Basic Network Test Fixture</a></li>
<li><a href="networking/testing/rng_synchronization_tests.html#test-fixtures">RNG Test Harness</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#test-environment-setup">Replicon RNG Test Harness</a></li>
</ul>
<hr />
<p>For more detailed information on specific testing areas, refer to the corresponding documentation links above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-testing-overview"><a class="header" href="#networking-testing-overview">Networking Testing Overview</a></h1>
<p>This document provides a comprehensive overview of the testing approach for the Rummage MTG Commander game engine's networking functionality.</p>
<h2 id="table-of-contents-13"><a class="header" href="#table-of-contents-13">Table of Contents</a></h2>
<ol>
<li><a href="networking/testing/overview.html#introduction">Introduction</a></li>
<li><a href="networking/testing/overview.html#testing-principles">Testing Principles</a></li>
<li><a href="networking/testing/overview.html#testing-levels">Testing Levels</a></li>
<li><a href="networking/testing/overview.html#test-fixtures">Test Fixtures</a></li>
<li><a href="networking/testing/overview.html#network-simulation">Network Simulation</a></li>
<li><a href="networking/testing/overview.html#automation-approach">Automation Approach</a></li>
</ol>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Networking code is inherently complex due to its asynchronous nature, potential for race conditions, and sensitivity to network conditions. Our testing approach is designed to address these challenges by employing a combination of unit tests, integration tests, and end-to-end tests, with a focus on simulating real-world network conditions.</p>
<h2 id="testing-principles"><a class="header" href="#testing-principles">Testing Principles</a></h2>
<p>Our networking testing follows these core principles:</p>
<ol>
<li><strong>Deterministic Tests</strong>: Tests should be repeatable and produce the same results given the same inputs</li>
<li><strong>Isolation</strong>: Individual tests should run independently without relying on state from other tests</li>
<li><strong>Real-World Conditions</strong>: Tests should simulate various network conditions including latency, packet loss, and disconnections</li>
<li><strong>Comprehensive Coverage</strong>: Tests should cover all networking components and their interactions</li>
<li><strong>Performance Validation</strong>: Tests should validate that networking performs adequately under expected loads</li>
</ol>
<h2 id="testing-levels"><a class="header" href="#testing-levels">Testing Levels</a></h2>
<h3 id="unit-tests-5"><a class="header" href="#unit-tests-5">Unit Tests</a></h3>
<p>Unit tests focus on individual networking components in isolation:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_message_serialization() {
    // Create a test message
    let message = NetworkMessage::GameAction {
        sequence_id: 123,
        player_id: 456,
        action: GameAction::DrawCard { player_id: 456, count: 1 },
    };
    
    // Serialize the message
    let serialized = bincode::serialize(&amp;message).expect("Serialization failed");
    
    // Deserialize the message
    let deserialized: NetworkMessage = bincode::deserialize(&amp;serialized).expect("Deserialization failed");
    
    // Verify the deserialized message matches the original
    assert_eq!(message, deserialized);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-tests-5"><a class="header" href="#integration-tests-5">Integration Tests</a></h3>
<p>Integration tests verify that multiple components work together correctly:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_client_server_connection() {
    // Set up a server
    let mut server_app = App::new();
    server_app.add_plugins(MinimalPlugins)
        .add_plugins(RepliconServerPlugin::default());
    
    // Set up a client
    let mut client_app = App::new();
    client_app.add_plugins(MinimalPlugins)
        .add_plugins(RepliconClientPlugin::default());
    
    // Start the server
    server_app.world.resource_mut::&lt;RepliconServer&gt;()
        .start_endpoint(ServerEndpoint::new(8080));
    
    // Connect the client
    client_app.world.resource_mut::&lt;RepliconClient&gt;()
        .connect_endpoint(ClientEndpoint::new("127.0.0.1", 8080));
    
    // Run updates to establish connection
    for _ in 0..10 {
        server_app.update();
        client_app.update();
    }
    
    // Verify the client is connected
    let client = client_app.world.resource::&lt;RepliconClient&gt;();
    assert!(client.is_connected());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="end-to-end-tests-1"><a class="header" href="#end-to-end-tests-1">End-to-End Tests</a></h3>
<p>End-to-end tests verify complete game scenarios:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_multiplayer_game_flow() {
    // Set up a server with a game
    let mut server_app = setup_server_with_game();
    
    // Set up clients for multiple players
    let mut client_apps = vec![
        setup_client_app(0),
        setup_client_app(1),
        setup_client_app(2),
        setup_client_app(3),
    ];
    
    // Connect all clients
    connect_all_clients(&amp;mut server_app, &amp;mut client_apps);
    
    // Run a full game turn cycle
    run_game_turn_cycle(&amp;mut server_app, &amp;mut client_apps);
    
    // Verify game state is consistent across all clients
    verify_consistent_game_state(&amp;server_app, &amp;client_apps);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="test-fixtures"><a class="header" href="#test-fixtures">Test Fixtures</a></h2>
<h3 id="basic-network-test-fixture"><a class="header" href="#basic-network-test-fixture">Basic Network Test Fixture</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Sets up a standard network test environment with server and clients
pub fn setup_network_test(app: &amp;mut App, is_server: bool, is_client: bool) {
    // Add required plugins
    app.add_plugins(MinimalPlugins);
    
    // Add either server or client plugins
    if is_server {
        app.add_plugins(RepliconServerPlugin::default());
    }
    
    if is_client {
        app.add_plugins(RepliconClientPlugin::default());
    }
    
    // Add networking resources
    app.init_resource::&lt;NetworkConfig&gt;()
        .init_resource::&lt;ConnectionStatus&gt;();
    
    // Add core networking systems
    app.add_systems(Update, network_connection_status_update);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="game-state-test-fixture"><a class="header" href="#game-state-test-fixture">Game State Test Fixture</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Sets up a test environment with a standard game state
pub fn setup_test_game_state(app: &amp;mut App) {
    // Add game state
    app.init_resource::&lt;GameState&gt;();
    
    // Set up players
    let player_entities = spawn_test_players(app);
    
    // Set up initial game board
    setup_test_board_state(app, &amp;player_entities);
    
    // Initialize game systems
    app.add_systems(Update, (
        update_game_state,
        process_game_actions,
        sync_game_state,
    ));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="network-simulation"><a class="header" href="#network-simulation">Network Simulation</a></h2>
<p>To test under various network conditions, we use a network condition simulator:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Simulates network conditions for testing
pub struct NetworkConditionSimulator {
    /// Simulated latency in milliseconds
    pub latency: u32,
    /// Packet loss percentage (0-100)
    pub packet_loss: u8,
    /// Jitter in milliseconds
    pub jitter: u32,
    /// Bandwidth cap in KB/s
    pub bandwidth: u32,
}

impl NetworkConditionSimulator {
    /// Applies network conditions to a packet
    pub fn process_packet(&amp;self, packet: &amp;mut Packet) {
        // Apply packet loss
        if rand::random::&lt;u8&gt;() &lt; self.packet_loss {
            packet.dropped = true;
            return;
        }
        
        // Apply latency with jitter
        let jitter_amount = if self.jitter &gt; 0 {
            rand::thread_rng().gen_range(0..self.jitter)
        } else {
            0
        };
        
        packet.delay = Duration::from_millis((self.latency + jitter_amount) as u64);
        
        // Apply bandwidth limitation
        if self.bandwidth &gt; 0 {
            packet.throttled = packet.size &gt; self.bandwidth;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="automation-approach"><a class="header" href="#automation-approach">Automation Approach</a></h2>
<p>Our testing automation strategy focuses on:</p>
<ol>
<li><strong>Continuous Integration</strong>: All networking tests run on every PR and merge to main</li>
<li><strong>Matrix Testing</strong>: Tests run against multiple configurations (OS, Bevy version, etc.)</li>
<li><strong>Performance Benchmarks</strong>: Regular testing of networking performance metrics</li>
<li><strong>Stress Testing</strong>: Load tests to verify behavior under heavy usage</li>
<li><strong>Long-running Tests</strong>: Tests that run for extended periods to catch time-dependent issues</li>
</ol>
<h2 id="key-test-scenarios-1"><a class="header" href="#key-test-scenarios-1">Key Test Scenarios</a></h2>
<p>The following critical scenarios must pass for all networking changes:</p>
<ol>
<li><strong>Connection Handling</strong>: Establishing connections, handling disconnections, and reconnections</li>
<li><strong>State Synchronization</strong>: Ensuring all clients see the same game state</li>
<li><strong>Latency Compensation</strong>: Verifying the game remains playable under various latency conditions</li>
<li><strong>Error Recovery</strong>: Testing recovery from network errors and disruptions</li>
<li><strong>Security</strong>: Validating that security measures work as expected</li>
</ol>
<hr />
<p>For more detailed testing information, see the <a href="networking/testing/rng_synchronization_tests.html">RNG Synchronization Tests</a> and <a href="networking/testing/replicon_rng_tests.html">Replicon RNG Tests</a> documents.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-rng-synchronization-in-networked-gameplay"><a class="header" href="#testing-rng-synchronization-in-networked-gameplay">Testing RNG Synchronization in Networked Gameplay</a></h1>
<p>This document outlines testing strategies for ensuring deterministic and synchronized random number generation across network boundaries in our MTG Commander game engine.</p>
<h2 id="table-of-contents-14"><a class="header" href="#table-of-contents-14">Table of Contents</a></h2>
<ol>
<li><a href="networking/testing/rng_synchronization_tests.html#testing-goals">Testing Goals</a></li>
<li><a href="networking/testing/rng_synchronization_tests.html#test-categories">Test Categories</a></li>
<li><a href="networking/testing/rng_synchronization_tests.html#test-fixtures">Test Fixtures</a></li>
<li><a href="networking/testing/rng_synchronization_tests.html#automated-tests">Automated Tests</a></li>
<li><a href="networking/testing/rng_synchronization_tests.html#manual-testing">Manual Testing</a></li>
<li><a href="networking/testing/rng_synchronization_tests.html#performance-considerations">Performance Considerations</a></li>
</ol>
<h2 id="testing-goals"><a class="header" href="#testing-goals">Testing Goals</a></h2>
<p>Testing RNG synchronization focuses on these key goals:</p>
<ol>
<li><strong>Determinism</strong>: Verify that identical RNG seeds produce identical random sequences on all clients</li>
<li><strong>State Preservation</strong>: Ensure RNG state is properly serialized, transmitted, and restored</li>
<li><strong>Resilience</strong>: Test recovery from network disruptions or client reconnections</li>
<li><strong>Sequence Integrity</strong>: Confirm that game actions using randomness always produce the same results</li>
</ol>
<h2 id="test-categories"><a class="header" href="#test-categories">Test Categories</a></h2>
<h3 id="basic-determinism-tests"><a class="header" href="#basic-determinism-tests">Basic Determinism Tests</a></h3>
<p>These tests verify that the underlying RNG components work deterministically:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_rng_determinism() {
    // Create two RNGs with the same seed
    let seed = 12345u64;
    let mut rng1 = WyRand::seed_from_u64(seed);
    let mut rng2 = WyRand::seed_from_u64(seed);
    
    // Generate sequences from both RNGs
    let sequence1: Vec&lt;u32&gt; = (0..100).map(|_| rng1.next_u32()).collect();
    let sequence2: Vec&lt;u32&gt; = (0..100).map(|_| rng2.next_u32()).collect();
    
    // Verify sequences are identical
    assert_eq!(sequence1, sequence2);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="serialization-tests"><a class="header" href="#serialization-tests">Serialization Tests</a></h3>
<p>These tests verify that RNG state can be properly serialized and deserialized:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_rng_serialization() {
    // Create an RNG and use it to generate some values
    let mut original_rng = GlobalEntropy::&lt;WyRand&gt;::from_entropy();
    let original_values: Vec&lt;u32&gt; = (0..10).map(|_| original_rng.next_u32()).collect();
    
    // Serialize the RNG state
    let serialized_state = original_rng.try_serialize_state().expect("Failed to serialize RNG state");
    
    // Create a new RNG and deserialize the state into it
    let mut new_rng = GlobalEntropy::&lt;WyRand&gt;::from_entropy();
    new_rng.deserialize_state(&amp;serialized_state).expect("Failed to deserialize RNG state");
    
    // Generate the same number of values from the new RNG
    let new_values: Vec&lt;u32&gt; = (0..10).map(|_| new_rng.next_u32()).collect();
    
    // The values should be the same, since the states were synchronized
    assert_eq!(original_values, new_values);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="network-transmission-tests"><a class="header" href="#network-transmission-tests">Network Transmission Tests</a></h3>
<p>These tests verify that RNG state can be properly transmitted across the network:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_rng_network_transmission() {
    // Setup server and client apps
    let mut server_app = App::new();
    let mut client_app = App::new();
    
    // Configure apps for network testing
    setup_network_test(&amp;mut server_app, true, false);
    setup_network_test(&amp;mut client_app, false, true);
    
    // Run updates to establish connection
    for _ in 0..5 {
        server_app.update();
        client_app.update();
    }
    
    // Generate some random values on the server
    let server_values = {
        let mut rng = server_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..10).map(|_| rng.next_u32()).collect::&lt;Vec&lt;_&gt;&gt;()
    };
    
    // Serialize and send RNG state from server to client
    let serialized_state = {
        let rng = server_app.world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        rng.try_serialize_state().expect("Failed to serialize RNG state")
    };
    
    // Simulate network transmission
    let rng_message = RngStateMessage {
        state: serialized_state,
        timestamp: server_app.world.resource::&lt;Time&gt;().elapsed_seconds(),
    };
    
    // Apply the RNG state to the client
    {
        let mut client_rng = client_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        client_rng.deserialize_state(&amp;rng_message.state).expect("Failed to deserialize RNG state");
    }
    
    // Generate the same number of values on the client
    let client_values = {
        let mut rng = client_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..10).map(|_| rng.next_u32()).collect::&lt;Vec&lt;_&gt;&gt;()
    };
    
    // Verify the values match
    assert_eq!(server_values, client_values);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="player-specific-rng-tests"><a class="header" href="#player-specific-rng-tests">Player-Specific RNG Tests</a></h3>
<p>These tests verify that player-specific RNGs maintain determinism:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_player_rng_forking() {
    let mut app = App::new();
    app.add_plugins(MinimalPlugins)
        .add_plugins(EntropyPlugin::&lt;WyRand&gt;::default())
        .init_resource::&lt;PlayerRegistry&gt;();
    
    // Add test systems
    app.add_systems(Startup, setup_test_players)
        .add_systems(Update, fork_player_rngs);
    
    // Run the app to set up players and fork RNGs
    app.update();
    
    // Get player entities
    let player_registry = app.world.resource::&lt;PlayerRegistry&gt;();
    let player1 = player_registry.get_player(1);
    let player2 = player_registry.get_player(2);
    
    // Generate random sequences for each player
    let player1_values = generate_random_sequence(&amp;mut app.world, player1);
    let player2_values = generate_random_sequence(&amp;mut app.world, player2);
    
    // Values should be different because they were forked from the global RNG
    assert_ne!(player1_values, player2_values);
    
    // Save player RNG states
    save_player_rng_states(&amp;mut app.world);
    
    // Create a new app and restore the states
    let mut new_app = App::new();
    // Configure new app
    // ...
    
    // Restore the player RNG states
    restore_player_rng_states(&amp;mut new_app.world);
    
    // Generate new sequences
    let new_player1_values = generate_random_sequence(&amp;mut new_app.world, player1);
    let new_player2_values = generate_random_sequence(&amp;mut new_app.world, player2);
    
    // New sequences should match the original ones
    assert_eq!(player1_values, new_player1_values);
    assert_eq!(player2_values, new_player2_values);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="game-action-tests"><a class="header" href="#game-action-tests">Game Action Tests</a></h3>
<p>These tests verify that game actions involving randomness produce consistent results:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_shuffle_library_determinism() {
    // Setup test environment
    let mut app = setup_multiplayer_test_app();
    
    // Create a deck with known order
    let cards = (1..53).collect::&lt;Vec&lt;_&gt;&gt;();
    
    // Setup player and library
    let player_entity = spawn_test_player(&amp;mut app.world);
    let library_entity = spawn_test_library(&amp;mut app.world, player_entity, cards.clone());
    
    // Seed the player's RNG
    seed_player_rng(&amp;mut app.world, player_entity, 12345u64);
    
    // First shuffle
    app.world.send_event(ShuffleLibraryEvent { library_entity });
    app.update();
    
    // Get shuffled order
    let first_shuffle = get_library_order(&amp;app.world, library_entity);
    
    // Reset library and RNG to original state
    reset_library(&amp;mut app.world, library_entity, cards.clone());
    seed_player_rng(&amp;mut app.world, player_entity, 12345u64);
    
    // Second shuffle
    app.world.send_event(ShuffleLibraryEvent { library_entity });
    app.update();
    
    // Get shuffled order
    let second_shuffle = get_library_order(&amp;app.world, library_entity);
    
    // Both shuffles should result in the same order
    assert_eq!(first_shuffle, second_shuffle);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="test-fixtures-1"><a class="header" href="#test-fixtures-1">Test Fixtures</a></h2>
<p>Common test fixtures for RNG testing:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Sets up a test environment with multiple clients
pub fn setup_multiplayer_rng_test() -&gt; TestHarness {
    let mut harness = TestHarness::new();
    
    // Setup server
    harness.create_server_app();
    
    // Setup multiple clients
    for i in 0..4 {
        harness.create_client_app(i);
    }
    
    // Initialize RNG with a fixed seed
    harness.seed_global_rng(12345u64);
    
    // Connect clients to server
    harness.connect_all_clients();
    
    harness
}

/// Executes a randomized game action on all clients and verifies consistency
pub fn verify_random_action_consistency(harness: &amp;mut TestHarness, action: RandomizedAction) {
    // Execute action on server
    harness.execute_on_server(action.clone());
    
    // Synchronize RNG state to clients
    harness.sync_rng_state();
    
    // Execute same action on all clients
    let results = harness.execute_on_all_clients(action);
    
    // All results should be identical
    let first_result = &amp;results[0];
    for result in &amp;results[1..] {
        assert_eq!(first_result, result);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="automated-tests"><a class="header" href="#automated-tests">Automated Tests</a></h2>
<h3 id="integration-with-ci-pipeline"><a class="header" href="#integration-with-ci-pipeline">Integration with CI Pipeline</a></h3>
<p>Include these RNG synchronization tests in the CI pipeline:</p>
<pre><code class="language-yaml"># .github/workflows/rng-tests.yml
name: RNG Synchronization Tests

on:
  push:
    branches: [ main ]
    paths:
      - 'src/networking/rng/**'
      - 'src/game_engine/actions/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'src/networking/rng/**'
      - 'src/game_engine/actions/**'

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
      - name: Run RNG tests
        run: cargo test --package rummage --lib networking::rng
</code></pre>
<h3 id="test-coverage-requirements"><a class="header" href="#test-coverage-requirements">Test Coverage Requirements</a></h3>
<p>Aim for these coverage targets for RNG synchronization code:</p>
<ol>
<li><strong>Line Coverage</strong>: At least 90%</li>
<li><strong>Branch Coverage</strong>: At least 85%</li>
<li><strong>Function Coverage</strong>: 100%</li>
</ol>
<h2 id="manual-testing"><a class="header" href="#manual-testing">Manual Testing</a></h2>
<p>Some aspects of RNG synchronization should be manually tested:</p>
<ol>
<li><strong>Disconnection Recovery</strong>: Test that clients reconnecting receive correct RNG state</li>
<li><strong>High Latency Scenarios</strong>: Test with artificially high network latency</li>
<li><strong>Packet Loss</strong>: Test with simulated packet loss to verify recovery</li>
<li><strong>Cross-Platform Consistency</strong>: Verify RNG consistency between different operating systems</li>
</ol>
<h2 id="performance-considerations-2"><a class="header" href="#performance-considerations-2">Performance Considerations</a></h2>
<p>When testing RNG synchronization, monitor these performance metrics:</p>
<ol>
<li><strong>Serialization Size</strong>: RNG state should be compact</li>
<li><strong>Synchronization Frequency</strong>: Balance consistency vs. network overhead</li>
<li><strong>CPU Overhead</strong>: Monitor CPU usage during RNG-heavy operations</li>
<li><strong>Memory Usage</strong>: Track memory usage when many player-specific RNGs are active</li>
</ol>
<h2 id="documentation-and-logging"><a class="header" href="#documentation-and-logging">Documentation and Logging</a></h2>
<p>Implement thorough logging for RNG synchronization to aid in debugging:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn log_rng_sync(
    rng_state: Res&lt;RngStateTracker&gt;,
    client_id: Option&lt;Res&lt;ClientId&gt;&gt;,
) {
    if let Some(client_id) = client_id {
        info!(
            "RNG sync: Client {} received state of size {} bytes (timestamp: {})",
            client_id.0,
            rng_state.global_state.len(),
            rng_state.last_sync
        );
    } else {
        info!(
            "RNG sync: Server updated state of size {} bytes (timestamp: {})",
            rng_state.global_state.len(),
            rng_state.last_sync
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-replicon-integration-with-rng-state-management"><a class="header" href="#testing-replicon-integration-with-rng-state-management">Testing Replicon Integration with RNG State Management</a></h1>
<p>This document outlines specific test cases and methodologies for verifying the correct integration of bevy_replicon with our RNG state management system.</p>
<h2 id="table-of-contents-15"><a class="header" href="#table-of-contents-15">Table of Contents</a></h2>
<ol>
<li><a href="networking/testing/replicon_rng_tests.html#introduction">Introduction</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#test-environment-setup">Test Environment Setup</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#unit-tests">Unit Tests</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#integration-tests">Integration Tests</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#end-to-end-tests">End-to-End Tests</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#performance-tests">Performance Tests</a></li>
<li><a href="networking/testing/replicon_rng_tests.html#debugging-failures">Debugging Failures</a></li>
</ol>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>Testing the integration of bevy_replicon with RNG state management presents unique challenges:</p>
<ol>
<li>Network conditions are variable and unpredictable</li>
<li>Randomized operations must be deterministic across network boundaries</li>
<li>Rollbacks must preserve the exact RNG state</li>
<li>Any deviations in RNG state can lead to unpredictable game outcomes</li>
</ol>
<p>Our testing approach focuses on verifying determinism under various network conditions and ensuring proper recovery after disruptions.</p>
<h2 id="test-environment-setup"><a class="header" href="#test-environment-setup">Test Environment Setup</a></h2>
<h3 id="local-network-testing-harness"><a class="header" href="#local-network-testing-harness">Local Network Testing Harness</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Struct for testing replicon and RNG integration 
pub struct RepliconRngTestHarness {
    /// Server application
    pub server_app: App,
    /// Client applications (can have multiple)
    pub client_apps: Vec&lt;App&gt;,
    /// Network conditions simulator
    pub network_conditions: NetworkConditionSimulator,
    /// Test seed for deterministic behavior
    pub test_seed: u64,
}

impl RepliconRngTestHarness {
    /// Create a new test harness with the specified number of clients
    pub fn new(num_clients: usize) -&gt; Self {
        let mut server_app = App::new();
        let mut client_apps = Vec::with_capacity(num_clients);
        
        // Setup server
        server_app.add_plugins(MinimalPlugins)
                  .add_plugins(DefaultRngPlugin)
                  .add_plugins(RepliconServerPlugin::default())
                  .add_plugin(RepliconRngRollbackPlugin);
        
        // Setup RNG with specific seed for repeatability
        let test_seed = 12345u64;
        server_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;().seed_from_u64(test_seed);
        
        // Setup clients
        for _ in 0..num_clients {
            let mut client_app = App::new();
            client_app.add_plugins(MinimalPlugins)
                     .add_plugins(DefaultRngPlugin)
                     .add_plugins(RepliconClientPlugin::default())
                     .add_plugin(RepliconRngRollbackPlugin);
                     
            // Each client gets the same seed
            client_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;().seed_from_u64(test_seed);
            
            client_apps.push(client_app);
        }
        
        Self {
            server_app,
            client_apps,
            network_conditions: NetworkConditionSimulator::default(),
            test_seed,
        }
    }
    
    /// Connect all clients to the server
    pub fn connect_all_clients(&amp;mut self) {
        // Setup server to listen
        let server_port = 8080;
        self.server_app.world.resource_mut::&lt;RepliconServer&gt;()
            .start_endpoint(ServerEndpoint::new(server_port));
        
        // Connect clients
        for (i, client_app) in self.client_apps.iter_mut().enumerate() {
            client_app.world.resource_mut::&lt;RepliconClient&gt;()
                .connect_endpoint(ClientEndpoint::new("127.0.0.1", server_port));
        }
        
        // Update a few times to establish connections
        for _ in 0..10 {
            self.server_app.update();
            for client_app in &amp;mut self.client_apps {
                client_app.update();
            }
        }
    }
    
    /// Simulate network disruption for a specific client
    pub fn simulate_disruption(&amp;mut self, client_idx: usize, duration_ms: u64) {
        self.network_conditions.disconnect_client(client_idx, duration_ms);
    }
    
    /// Run a test with network conditions
    pub fn run_with_conditions&lt;F&gt;(&amp;mut self, update_count: usize, test_fn: F) 
    where F: Fn(&amp;mut Self, usize) {
        for i in 0..update_count {
            // Apply network conditions
            self.network_conditions.update(&amp;mut self.client_apps);
            
            // Run server update
            self.server_app.update();
            
            // Run client updates
            for client_app in &amp;mut self.client_apps {
                client_app.update();
            }
            
            // Call test function
            test_fn(self, i);
        }
    }
}

/// Simulates different network conditions
pub struct NetworkConditionSimulator {
    /// Client disconnection timers
    pub disconnection_timers: HashMap&lt;usize, u64&gt;,
    /// Packet loss percentages
    pub packet_loss_rates: HashMap&lt;usize, f32&gt;,
    /// Latency values
    pub latencies: HashMap&lt;usize, u64&gt;,
}

impl NetworkConditionSimulator {
    /// Disconnect a client for a duration
    pub fn disconnect_client(&amp;mut self, client_idx: usize, duration_ms: u64) {
        self.disconnection_timers.insert(client_idx, duration_ms);
    }
    
    /// Apply network conditions to clients
    pub fn update(&amp;mut self, client_apps: &amp;mut [App]) {
        // Update disconnection timers and reconnect if needed
        let mut reconnect = Vec::new();
        for (client_idx, timer) in &amp;mut self.disconnection_timers {
            if *timer &lt;= 16 {
                reconnect.push(*client_idx);
            } else {
                *timer -= 16; // Assuming 60 FPS
            }
        }
        
        for client_idx in reconnect {
            self.disconnection_timers.remove(&amp;client_idx);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="unit-tests-6"><a class="header" href="#unit-tests-6">Unit Tests</a></h2>
<h3 id="testing-rng-state-serialization-and-deserialization"><a class="header" href="#testing-rng-state-serialization-and-deserialization">Testing RNG State Serialization and Deserialization</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_rng_state_serialization() {
    // Create a test app
    let mut app = App::new();
    app.add_plugins(MinimalPlugins)
       .add_plugins(DefaultRngPlugin)
       .init_resource::&lt;RngReplicationState&gt;();
    
    // Setup global RNG with specific seed
    let test_seed = 12345u64;
    app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;().seed_from_u64(test_seed);
    
    // Generate some random values and store them
    let original_values: Vec&lt;u32&gt; = {
        let mut rng = app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..10).map(|_| rng.gen::&lt;u32&gt;()).collect()
    };
    
    // Capture the RNG state
    let mut rng_state = app.world.resource_mut::&lt;RngReplicationState&gt;();
    let global_rng = app.world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
    rng_state.global_state = global_rng.try_serialize_state().unwrap();
    
    // Create a new app with fresh RNG
    let mut new_app = App::new();
    new_app.add_plugins(MinimalPlugins)
           .add_plugins(DefaultRngPlugin);
    
    // Apply the saved state
    let mut new_global_rng = new_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
    new_global_rng.deserialize_state(&amp;rng_state.global_state).unwrap();
    
    // Generate values from the new RNG
    let new_values: Vec&lt;u32&gt; = {
        let mut rng = new_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..10).map(|_| rng.gen::&lt;u32&gt;()).collect()
    };
    
    // Values should be different from the original sequence
    // because we captured the state after generating the original values
    assert_ne!(original_values, new_values);
    
    // Reset both RNGs to the same seed and generate sequences
    app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;().seed_from_u64(test_seed);
    new_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;().seed_from_u64(test_seed);
    
    let reset_values1: Vec&lt;u32&gt; = {
        let mut rng = app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..10).map(|_| rng.gen::&lt;u32&gt;()).collect()
    };
    
    let reset_values2: Vec&lt;u32&gt; = {
        let mut rng = new_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..10).map(|_| rng.gen::&lt;u32&gt;()).collect()
    };
    
    // Values should now be identical
    assert_eq!(reset_values1, reset_values2);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-checkpoint-creation-and-restoration"><a class="header" href="#testing-checkpoint-creation-and-restoration">Testing Checkpoint Creation and Restoration</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_checkpoint_creation_and_restoration() {
    // Create a test app with the plugin
    let mut app = App::new();
    app.add_plugins(MinimalPlugins)
       .add_plugins(DefaultRngPlugin)
       .add_plugin(RepliconRngRollbackPlugin)
       .init_resource::&lt;SequenceTracker&gt;();
    
    // Seed RNG
    let test_seed = 12345u64;
    app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;().seed_from_u64(test_seed);
    
    // Generate some initial values
    let initial_values: Vec&lt;u32&gt; = {
        let mut rng = app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..5).map(|_| rng.gen::&lt;u32&gt;()).collect()
    };
    
    // Create a checkpoint
    let checkpoint_sequence = 1;
    let mut checkpoints = app.world.resource_mut::&lt;RollbackCheckpoints&gt;();
    let rng_state = app.world.resource::&lt;RngReplicationState&gt;();
    let global_rng = app.world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
    
    let checkpoint = RollbackCheckpoint {
        sequence_id: checkpoint_sequence,
        timestamp: 0.0,
        global_rng_state: global_rng.try_serialize_state().unwrap(),
        player_rng_states: HashMap::new(),
        replicated_entities: Vec::new(),
    };
    
    checkpoints.checkpoints.insert(checkpoint_sequence, checkpoint);
    
    // Generate more values after checkpoint
    let post_checkpoint_values: Vec&lt;u32&gt; = {
        let mut rng = app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..5).map(|_| rng.gen::&lt;u32&gt;()).collect()
    };
    
    // Restore from checkpoint
    let checkpoint = checkpoints.checkpoints.get(&amp;checkpoint_sequence).unwrap();
    app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;()
        .deserialize_state(&amp;checkpoint.global_rng_state).unwrap();
    
    // Generate values after restoration
    let restored_values: Vec&lt;u32&gt; = {
        let mut rng = app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
        (0..5).map(|_| rng.gen::&lt;u32&gt;()).collect()
    };
    
    // The restored values should match the post-checkpoint values
    assert_eq!(post_checkpoint_values, restored_values);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-tests-6"><a class="header" href="#integration-tests-6">Integration Tests</a></h2>
<h3 id="testing-rng-synchronization-between-server-and-client"><a class="header" href="#testing-rng-synchronization-between-server-and-client">Testing RNG Synchronization Between Server and Client</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_server_client_rng_sync() {
    // Create test harness with 1 client
    let mut harness = RepliconRngTestHarness::new(1);
    harness.connect_all_clients();
    
    // Test variables
    let mut server_values = Vec::new();
    let mut client_values = Vec::new();
    
    // Run with updates
    harness.run_with_conditions(50, |harness, i| {
        if i == 10 {
            // Record server RNG values at update 10
            let mut rng = harness.server_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            server_values = (0..5).map(|_| rng.gen::&lt;u32&gt;()).collect();
        }
        
        if i == 20 {
            // Record client RNG values at update 20
            // By now, RNG state should have been synced
            let mut rng = harness.client_apps[0].world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            client_values = (0..5).map(|_| rng.gen::&lt;u32&gt;()).collect();
            
            // Server will have advanced, get fresh set of values
            let mut rng = harness.server_app.world.resource_mut::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            server_values = (0..5).map(|_| rng.gen::&lt;u32&gt;()).collect();
        }
    });
    
    // Client values should match server values from update 20
    assert_eq!(client_values, server_values);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-rollback-due-to-network-disruption"><a class="header" href="#testing-rollback-due-to-network-disruption">Testing Rollback Due to Network Disruption</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_rollback_after_disruption() {
    // Create test harness with 2 clients
    let mut harness = RepliconRngTestHarness::new(2);
    harness.connect_all_clients();
    
    // Setup game entities
    // ...
    
    // Run test with network disruption
    let mut pre_disruption_rng_values = Vec::new();
    let mut post_disruption_rng_values = Vec::new();
    let mut post_rollback_rng_values = Vec::new();
    
    harness.run_with_conditions(100, |harness, i| {
        if i == 20 {
            // Record RNG values before disruption
            let rng = harness.server_app.world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            pre_disruption_rng_values = generate_test_random_values(rng, 10);
            
            // Simulate network disruption for client 0
            harness.simulate_disruption(0, 500); // 500ms disruption
        }
        
        if i == 40 {
            // Record RNG values after disruption
            let rng = harness.server_app.world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            post_disruption_rng_values = generate_test_random_values(rng, 10);
        }
        
        if i == 60 {
            // By now rollback should have happened
            // Record RNG values after rollback
            let rng = harness.server_app.world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            post_rollback_rng_values = generate_test_random_values(rng, 10);
            
            // Check that client 0 and client 1 have the same RNG state
            let rng0 = harness.client_apps[0].world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            let rng1 = harness.client_apps[1].world.resource::&lt;GlobalEntropy&lt;WyRand&gt;&gt;();
            
            let client0_values = generate_test_random_values(rng0, 10);
            let client1_values = generate_test_random_values(rng1, 10);
            
            assert_eq!(client0_values, client1_values, "Clients should have same RNG state after rollback");
        }
    });
    
    // Verify behavior
    assert_ne!(pre_disruption_rng_values, post_disruption_rng_values, 
               "RNG values should change during normal operation");
    assert_eq!(post_rollback_rng_values, post_disruption_rng_values, 
               "After rollback, RNG sequences should match the checkpoint state");
}

/// Helper function to generate random values for testing
fn generate_test_random_values(rng: &amp;GlobalEntropy&lt;WyRand&gt;, count: usize) -&gt; Vec&lt;u32&gt; {
    let mut rng_clone = rng.clone();
    (0..count).map(|_| rng_clone.gen::&lt;u32&gt;()).collect()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="end-to-end-tests-2"><a class="header" href="#end-to-end-tests-2">End-to-End Tests</a></h2>
<h3 id="testing-card-shuffling-during-network-disruption"><a class="header" href="#testing-card-shuffling-during-network-disruption">Testing Card Shuffling During Network Disruption</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_card_shuffle_during_disruption() {
    // Setup test environment with card library
    let mut harness = RepliconRngTestHarness::new(2);
    harness.connect_all_clients();
    
    // Create players and libraries
    let server_player1 = setup_test_player(&amp;mut harness.server_app.world, 1);
    let server_player2 = setup_test_player(&amp;mut harness.server_app.world, 2);
    
    // Create identical card libraries
    let cards = (1..53).collect::&lt;Vec&lt;i32&gt;&gt;();
    let server_library1 = create_test_library(&amp;mut harness.server_app.world, server_player1, cards.clone());
    let server_library2 = create_test_library(&amp;mut harness.server_app.world, server_player2, cards.clone());
    
    // Initialize client players and libraries
    // ...
    
    // Shuffle results
    let mut server_shuffle_result1 = Vec::new();
    let mut server_shuffle_result2 = Vec::new();
    let mut client1_shuffle_result = Vec::new();
    let mut client2_shuffle_result = Vec::new();
    
    // Run test with network disruption during card shuffle
    harness.run_with_conditions(200, |harness, i| {
        if i == 50 {
            // Player 1 shuffles their library
            harness.server_app.world.send_event(ShuffleLibraryEvent { 
                library_entity: server_library1 
            });
        }
        
        if i == 60 {
            // Capture shuffle result
            server_shuffle_result1 = get_library_order(&amp;harness.server_app.world, server_library1);
            
            // Cause network disruption
            harness.simulate_disruption(0, 1000);
        }
        
        if i == 80 {
            // Player 2 shuffles during disruption
            harness.server_app.world.send_event(ShuffleLibraryEvent { 
                library_entity: server_library2 
            });
        }
        
        if i == 100 {
            // Capture server-side shuffle results
            server_shuffle_result2 = get_library_order(&amp;harness.server_app.world, server_library2);
        }
        
        if i == 150 {
            // By now, rollback and resynchronization should have occurred
            // Capture client-side shuffle results
            client1_shuffle_result = get_client_library_order(&amp;harness.client_apps[0].world, 1);
            client2_shuffle_result = get_client_library_order(&amp;harness.client_apps[1].world, 2);
        }
    });
    
    // Verify all libraries have the same shuffle result
    assert_eq!(server_shuffle_result1, client1_shuffle_result, 
               "Client 1 should have same shuffle result as server");
    assert_eq!(server_shuffle_result2, client2_shuffle_result, 
               "Client 2 should have same shuffle result as server");
}

/// Helper function to get library card order
fn get_library_order(world: &amp;World, library_entity: Entity) -&gt; Vec&lt;i32&gt; {
    if let Some(library) = world.get::&lt;Library&gt;(library_entity) {
        library.cards.clone()
    } else {
        Vec::new()
    }
}

/// Helper function to get client-side library order
fn get_client_library_order(client_world: &amp;World, player_id: i32) -&gt; Vec&lt;i32&gt; {
    // Find player by ID
    let player_entity = find_player_by_id(client_world, player_id);
    if player_entity.is_none() { return Vec::new(); }
    
    // Find library entity
    let library_entity = find_library_for_player(client_world, player_entity.unwrap());
    if library_entity.is_none() { return Vec::new(); }
    
    // Get library cards
    get_library_order(client_world, library_entity.unwrap())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-tests-3"><a class="header" href="#performance-tests-3">Performance Tests</a></h2>
<h3 id="testing-rng-state-replication-bandwidth"><a class="header" href="#testing-rng-state-replication-bandwidth">Testing RNG State Replication Bandwidth</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_rng_replication_bandwidth() {
    // Create a test harness with multiple clients
    let mut harness = RepliconRngTestHarness::new(4);
    harness.connect_all_clients();
    
    // Setup bandwidth tracking
    let mut bandwidth_tracker = BandwidthTracker::new();
    
    // Run test with bandwidth monitoring
    harness.run_with_conditions(100, |harness, i| {
        if i % 10 == 0 {
            // Record bandwidth usage every 10 updates
            let server = harness.server_app.world.resource::&lt;RepliconServer&gt;();
            bandwidth_tracker.record_bandwidth(server.get_bandwidth_stats());
        }
    });
    
    // Analyze bandwidth results
    let results = bandwidth_tracker.analyze();
    
    // Ensure RNG state replication is within reasonable bounds
    assert!(results.avg_bandwidth_per_client &lt; 1024, 
            "Average bandwidth should be less than 1KB per client");
    
    // Print results
    println!("Bandwidth results:");
    println!("  Average per client: {} bytes", results.avg_bandwidth_per_client);
    println!("  Peak: {} bytes", results.peak_bandwidth);
    println!("  Total: {} bytes", results.total_bandwidth);
}

/// Helper struct for tracking bandwidth usage
struct BandwidthTracker {
    samples: Vec&lt;BandwidthSample&gt;,
}

struct BandwidthSample {
    timestamp: f32,
    bytes_sent: usize,
    client_count: usize,
}

struct BandwidthResults {
    avg_bandwidth_per_client: f32,
    peak_bandwidth: usize,
    total_bandwidth: usize,
}

impl BandwidthTracker {
    fn new() -&gt; Self {
        Self { samples: Vec::new() }
    }
    
    fn record_bandwidth(&amp;mut self, stats: BandwidthStats) {
        self.samples.push(BandwidthSample {
            timestamp: stats.timestamp,
            bytes_sent: stats.bytes_sent,
            client_count: stats.client_count,
        });
    }
    
    fn analyze(&amp;self) -&gt; BandwidthResults {
        if self.samples.is_empty() {
            return BandwidthResults {
                avg_bandwidth_per_client: 0.0,
                peak_bandwidth: 0,
                total_bandwidth: 0,
            };
        }
        
        let total_bytes: usize = self.samples.iter().map(|s| s.bytes_sent).sum();
        let peak_bytes = self.samples.iter().map(|s| s.bytes_sent).max().unwrap_or(0);
        
        let client_samples: usize = self.samples.iter().map(|s| s.client_count).sum();
        let avg_per_client = if client_samples &gt; 0 {
            total_bytes as f32 / client_samples as f32
        } else {
            0.0
        };
        
        BandwidthResults {
            avg_bandwidth_per_client: avg_per_client,
            peak_bandwidth: peak_bytes,
            total_bandwidth: total_bytes,
        }
    }
}

/// Mock struct to represent network bandwidth statistics
struct BandwidthStats {
    timestamp: f32,
    bytes_sent: usize,
    client_count: usize,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="debugging-failures"><a class="header" href="#debugging-failures">Debugging Failures</a></h2>
<p>When tests fail, collect diagnostic information to aid debugging:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn diagnose_rng_state_mismatch(
    server_rng: &amp;GlobalEntropy&lt;WyRand&gt;,
    client_rng: &amp;GlobalEntropy&lt;WyRand&gt;,
) -&gt; String {
    // Serialize both RNG states
    let server_state = server_rng.try_serialize_state().unwrap_or_default();
    let client_state = client_rng.try_serialize_state().unwrap_or_default();
    
    // Generate test values from both
    let mut server_rng_clone = server_rng.clone();
    let mut client_rng_clone = client_rng.clone();
    
    let server_values: Vec&lt;u32&gt; = (0..5).map(|_| server_rng_clone.gen::&lt;u32&gt;()).collect();
    let client_values: Vec&lt;u32&gt; = (0..5).map(|_| client_rng_clone.gen::&lt;u32&gt;()).collect();
    
    let mut report = String::new();
    report.push_str("RNG State Mismatch Diagnostic:\n");
    report.push_str(&amp;format!("Server state: {:?}\n", server_state));
    report.push_str(&amp;format!("Client state: {:?}\n", client_state));
    report.push_str(&amp;format!("Server values: {:?}\n", server_values));
    report.push_str(&amp;format!("Client values: {:?}\n", client_values));
    
    report
}
<span class="boring">}</span></code></pre></pre>
<hr />
<p>These tests validate that our bevy_replicon integration with RNG state management works correctly under various conditions, ensuring deterministic behavior in our networked MTG Commander game.</p>
<p>Remember to run these tests:</p>
<ol>
<li>Regularly during development</li>
<li>After any changes to networking code</li>
<li>After any changes to RNG-dependent game logic</li>
<li>As part of the CI/CD pipeline</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-documentation-for-mtg-commander-networking"><a class="header" href="#security-documentation-for-mtg-commander-networking">Security Documentation for MTG Commander Networking</a></h1>
<p>This section covers the security aspects of the MTG Commander game engine's networking implementation. Security is a critical consideration for any multiplayer game, especially one that involves hidden information and competitive gameplay.</p>
<h2 id="overview-11"><a class="header" href="#overview-11">Overview</a></h2>
<p>The security implementation for the MTG Commander game engine focuses on several key areas:</p>
<ol>
<li><strong>Authentication and Authorization</strong>: Ensuring only legitimate users can access the game</li>
<li><strong>Hidden Information Management</strong>: Protecting game-critical hidden information</li>
<li><strong>Anti-Cheat Measures</strong>: Preventing and detecting cheating attempts</li>
<li><strong>Network Security</strong>: Securing communication between clients and servers</li>
<li><strong>Data Protection</strong>: Safeguarding user data and game state</li>
</ol>
<h2 id="security-components"><a class="header" href="#security-components">Security Components</a></h2>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<p>The <a href="networking/security/authentication.html">Authentication</a> system ensures that only legitimate users can connect to and participate in games. It covers:</p>
<ul>
<li>User identity verification</li>
<li>Session management</li>
<li>Credential security</li>
<li>Protection against common authentication attacks</li>
</ul>
<h3 id="anti-cheat"><a class="header" href="#anti-cheat">Anti-Cheat</a></h3>
<p>The <a href="networking/security/anti_cheat.html">Anti-Cheat</a> system prevents players from gaining unfair advantages through technical means. It addresses:</p>
<ul>
<li>Client modification detection</li>
<li>Memory manipulation prevention</li>
<li>Network traffic validation</li>
<li>Anomaly detection and response</li>
<li>Enforcement of game rules</li>
</ul>
<h3 id="hidden-information-management"><a class="header" href="#hidden-information-management">Hidden Information Management</a></h3>
<p>The <a href="networking/security/hidden_information.html">Hidden Information</a> system protects game-critical information that should be hidden from some or all players. It covers:</p>
<ul>
<li>Player hand protection</li>
<li>Library content and order security</li>
<li>Face-down card management</li>
<li>Selective information revelation</li>
<li>Server-side information control</li>
</ul>
<h2 id="security-testing"><a class="header" href="#security-testing">Security Testing</a></h2>
<p>Security testing is a critical aspect of ensuring the robustness of our security measures. For details on how we test security features, see the <a href="networking/security/../testing/security/strategy.html">Security Testing Strategy</a>.</p>
<h2 id="implementation-principles-2"><a class="header" href="#implementation-principles-2">Implementation Principles</a></h2>
<p>Our security implementation follows these core principles:</p>
<ol>
<li><strong>Defense in Depth</strong>: Multiple layers of security to protect against different types of threats</li>
<li><strong>Least Privilege</strong>: Components only have access to the information and capabilities they need</li>
<li><strong>Server Authority</strong>: The server is the single source of truth for game state</li>
<li><strong>Secure by Default</strong>: Security is built into the system from the ground up</li>
<li><strong>Continuous Improvement</strong>: Security measures are regularly reviewed and enhanced</li>
</ol>
<h2 id="future-enhancements-5"><a class="header" href="#future-enhancements-5">Future Enhancements</a></h2>
<p>Planned security enhancements include:</p>
<ul>
<li>Enhanced encryption for sensitive game actions</li>
<li>Two-factor authentication support</li>
<li>Advanced anti-cheat measures using machine learning</li>
<li>Improved security testing automation</li>
<li>Expanded security documentation and best practices</li>
</ul>
<hr />
<p>This documentation will be updated as security measures evolve.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mtg-rules-reference"><a class="header" href="#mtg-rules-reference">MTG Rules Reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contribution-guidelines"><a class="header" href="#contribution-guidelines">Contribution Guidelines</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rummage-documentation"><a class="header" href="#rummage-documentation">Rummage Documentation</a></h1>
<p>This directory contains the comprehensive documentation for the Rummage MTG Commander game engine built with Bevy 0.15.x.</p>
<h2 id="documentation-structure-1"><a class="header" href="#documentation-structure-1">Documentation Structure</a></h2>
<p>The documentation is organized into the following major sections:</p>
<ol>
<li><strong><a href="commander/index.html">Commander Rules</a></strong> - Implementation of MTG Commander format rules and mechanics</li>
<li><strong><a href="game_gui/index.html">Game UI</a></strong> - User interface systems and components</li>
<li><strong><a href="networking/index.html">Networking</a></strong> - Multiplayer functionality using bevy_replicon</li>
</ol>
<h2 id="contributing-to-documentation"><a class="header" href="#contributing-to-documentation">Contributing to Documentation</a></h2>
<p>When contributing to the documentation, please follow these guidelines:</p>
<h3 id="document-structure"><a class="header" href="#document-structure">Document Structure</a></h3>
<p>Each document should have:</p>
<ol>
<li>A clear, descriptive title</li>
<li>A brief introduction explaining the document's purpose</li>
<li>A table of contents for documents longer than a few paragraphs</li>
<li>Properly nested headings (H1 -&gt; H2 -&gt; H3)</li>
<li>Code examples where appropriate</li>
<li>Cross-references to related documents</li>
<li>Implementation status indicators where appropriate</li>
</ol>
<h3 id="style-guide"><a class="header" href="#style-guide">Style Guide</a></h3>
<ol>
<li>Use American English spelling and grammar</li>
<li>Write in a clear, concise style</li>
<li>Use active voice where possible</li>
<li>Keep paragraphs focused on a single topic</li>
<li>Use proper Markdown formatting:
<ul>
<li><code>#</code> for headings (not underlines)</li>
<li>Backticks for code snippets</li>
<li>Triple backticks for code blocks with language identifier</li>
<li>Dashes for unordered lists</li>
<li>Numbers for ordered lists</li>
</ul>
</li>
</ol>
<h3 id="code-examples"><a class="header" href="#code-examples">Code Examples</a></h3>
<p>Include meaningful code examples that:</p>
<ol>
<li>Use non-deprecated Bevy 0.15.x APIs</li>
<li>Demonstrate the concept being explained</li>
<li>Are syntactically correct</li>
<li>Include comments for complex code</li>
<li>Use Rust syntax highlighting with ````rust`</li>
</ol>
<h3 id="implementation-status-3"><a class="header" href="#implementation-status-3">Implementation Status</a></h3>
<p>Use the following indicators to mark implementation status:</p>
<ul>
<li>‚úÖ Implemented and tested</li>
<li>üîÑ In progress</li>
<li>‚ö†Ô∏è Planned but not yet implemented</li>
</ul>
<h2 id="building-the-documentation"><a class="header" href="#building-the-documentation">Building the Documentation</a></h2>
<p>We use <code>mdbook</code> to build the documentation. To get started:</p>
<ol>
<li>
<p>Install required tools:</p>
<pre><code class="language-bash">make install-tools
</code></pre>
</li>
<li>
<p>Build the documentation:</p>
<pre><code class="language-bash">make build
</code></pre>
</li>
<li>
<p>View the documentation locally:</p>
<pre><code class="language-bash">make serve
</code></pre>
</li>
</ol>
<p>Then open your browser to http://localhost:3000</p>
<h2 id="documentation-maintenance"><a class="header" href="#documentation-maintenance">Documentation Maintenance</a></h2>
<p>Use the following make commands for documentation maintenance:</p>
<ul>
<li><code>make lint</code> - Check for style issues</li>
<li><code>make toc</code> - Generate table of contents</li>
<li><code>make check</code> - Check for broken links</li>
<li><code>make validate</code> - Validate documentation structure</li>
<li><code>make update-dates</code> - Update last modified dates</li>
</ul>
<h2 id="questions"><a class="header" href="#questions">Questions?</a></h2>
<p>If you have questions about the documentation, please contact the documentation team or open an issue in the project repository.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/js/custom.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
